// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: action.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Yaw behaviour during orbit flight.
enum Mavsdk_Rpc_Action_OrbitYawBehavior: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Vehicle front points to the center (default)
  case holdFrontToCircleCenter // = 0

  /// Vehicle front holds heading when message received
  case holdInitialHeading // = 1

  /// Yaw uncontrolled
  case uncontrolled // = 2

  /// Vehicle front follows flight path (tangential to circle)
  case holdFrontTangentToCircle // = 3

  /// Yaw controlled by RC input
  case rcControlled // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .holdFrontToCircleCenter
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .holdFrontToCircleCenter
    case 1: self = .holdInitialHeading
    case 2: self = .uncontrolled
    case 3: self = .holdFrontTangentToCircle
    case 4: self = .rcControlled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .holdFrontToCircleCenter: return 0
    case .holdInitialHeading: return 1
    case .uncontrolled: return 2
    case .holdFrontTangentToCircle: return 3
    case .rcControlled: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Action_OrbitYawBehavior: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Action_OrbitYawBehavior] = [
    .holdFrontToCircleCenter,
    .holdInitialHeading,
    .uncontrolled,
    .holdFrontTangentToCircle,
    .rcControlled,
  ]
}

#endif  // swift(>=4.2)

struct Mavsdk_Rpc_Action_ArmRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_ArmResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_DisarmRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_DisarmResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_TakeoffRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_TakeoffResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_LandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_LandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_RebootRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_RebootResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_ShutdownRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_ShutdownResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_TerminateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_TerminateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_KillRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_KillResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_ReturnToLaunchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_ReturnToLaunchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_GotoLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Latitude (in degrees)
  var latitudeDeg: Double = 0

  /// Longitude (in degrees)
  var longitudeDeg: Double = 0

  /// Altitude AMSL (in meters)
  var absoluteAltitudeM: Float = 0

  /// Yaw angle (in degrees, frame is NED, 0 is North, positive is clockwise)
  var yawDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_GotoLocationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_DoOrbitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Radius of circle (in meters)
  var radiusM: Float = 0

  /// Tangential velocity (in m/s)
  var velocityMs: Float = 0

  /// Yaw behavior of vehicle (ORBIT_YAW_BEHAVIOUR)
  var yawBehavior: Mavsdk_Rpc_Action_OrbitYawBehavior = .holdFrontToCircleCenter

  /// Center point latitude in degrees. NAN: use current latitude for center
  var latitudeDeg: Double = 0

  /// Center point longitude in degrees. NAN: use current longitude for center
  var longitudeDeg: Double = 0

  /// Center point altitude in meters. NAN: use current altitude for center
  var absoluteAltitudeM: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_DoOrbitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_HoldRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_HoldResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_SetActuatorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index of actuator (starting with 1)
  var index: Int32 = 0

  /// Value to set the actuator to (normalized from [-1..1])
  var value: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_SetActuatorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_TransitionToFixedwingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_TransitionToFixedwingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_TransitionToMulticopterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_TransitionToMulticopterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_GetTakeoffAltitudeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_GetTakeoffAltitudeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  /// Takeoff altitude relative to ground/takeoff location (in meters)
  var altitude: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_SetTakeoffAltitudeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Takeoff altitude relative to ground/takeoff location (in meters)
  var altitude: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_SetTakeoffAltitudeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_GetMaximumSpeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_GetMaximumSpeedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  /// Maximum speed (in metres/second)
  var speed: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_SetMaximumSpeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum speed (in metres/second)
  var speed: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_SetMaximumSpeedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_GetReturnToLaunchAltitudeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_GetReturnToLaunchAltitudeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  /// Return altitude relative to takeoff location (in meters)
  var relativeAltitudeM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

struct Mavsdk_Rpc_Action_SetReturnToLaunchAltitudeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Return altitude relative to takeoff location (in meters)
  var relativeAltitudeM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Action_SetReturnToLaunchAltitudeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionResult: Mavsdk_Rpc_Action_ActionResult {
    get {return _actionResult ?? Mavsdk_Rpc_Action_ActionResult()}
    set {_actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  var hasActionResult: Bool {return self._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  mutating func clearActionResult() {self._actionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionResult: Mavsdk_Rpc_Action_ActionResult? = nil
}

/// Result type.
struct Mavsdk_Rpc_Action_ActionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result enum value
  var result: Mavsdk_Rpc_Action_ActionResult.Result = .unknown

  /// Human-readable English string describing the result
  var resultStr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible results returned for action requests.
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result
    case unknown // = 0

    /// Request was successful
    case success // = 1

    /// No system is connected
    case noSystem // = 2

    /// Connection error
    case connectionError // = 3

    /// Vehicle is busy
    case busy // = 4

    /// Command refused by vehicle
    case commandDenied // = 5

    /// Command refused because landed state is unknown
    case commandDeniedLandedStateUnknown // = 6

    /// Command refused because vehicle not landed
    case commandDeniedNotLanded // = 7

    /// Request timed out
    case timeout // = 8

    /// Hybrid/VTOL transition support is unknown
    case vtolTransitionSupportUnknown // = 9

    /// Vehicle does not support hybrid/VTOL transitions
    case noVtolTransitionSupport // = 10

    /// Error getting or setting parameter
    case parameterError // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .noSystem
      case 3: self = .connectionError
      case 4: self = .busy
      case 5: self = .commandDenied
      case 6: self = .commandDeniedLandedStateUnknown
      case 7: self = .commandDeniedNotLanded
      case 8: self = .timeout
      case 9: self = .vtolTransitionSupportUnknown
      case 10: self = .noVtolTransitionSupport
      case 11: self = .parameterError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .noSystem: return 2
      case .connectionError: return 3
      case .busy: return 4
      case .commandDenied: return 5
      case .commandDeniedLandedStateUnknown: return 6
      case .commandDeniedNotLanded: return 7
      case .timeout: return 8
      case .vtolTransitionSupportUnknown: return 9
      case .noVtolTransitionSupport: return 10
      case .parameterError: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mavsdk_Rpc_Action_ActionResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Action_ActionResult.Result] = [
    .unknown,
    .success,
    .noSystem,
    .connectionError,
    .busy,
    .commandDenied,
    .commandDeniedLandedStateUnknown,
    .commandDeniedNotLanded,
    .timeout,
    .vtolTransitionSupportUnknown,
    .noVtolTransitionSupport,
    .parameterError,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mavsdk.rpc.action"

extension Mavsdk_Rpc_Action_OrbitYawBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORBIT_YAW_BEHAVIOR_HOLD_FRONT_TO_CIRCLE_CENTER"),
    1: .same(proto: "ORBIT_YAW_BEHAVIOR_HOLD_INITIAL_HEADING"),
    2: .same(proto: "ORBIT_YAW_BEHAVIOR_UNCONTROLLED"),
    3: .same(proto: "ORBIT_YAW_BEHAVIOR_HOLD_FRONT_TANGENT_TO_CIRCLE"),
    4: .same(proto: "ORBIT_YAW_BEHAVIOR_RC_CONTROLLED"),
  ]
}

extension Mavsdk_Rpc_Action_ArmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArmRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_ArmRequest, rhs: Mavsdk_Rpc_Action_ArmRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_ArmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArmResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_ArmResponse, rhs: Mavsdk_Rpc_Action_ArmResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_DisarmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisarmRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_DisarmRequest, rhs: Mavsdk_Rpc_Action_DisarmRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_DisarmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisarmResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_DisarmResponse, rhs: Mavsdk_Rpc_Action_DisarmResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_TakeoffRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TakeoffRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_TakeoffRequest, rhs: Mavsdk_Rpc_Action_TakeoffRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_TakeoffResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TakeoffResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_TakeoffResponse, rhs: Mavsdk_Rpc_Action_TakeoffResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_LandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LandRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_LandRequest, rhs: Mavsdk_Rpc_Action_LandRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_LandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LandResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_LandResponse, rhs: Mavsdk_Rpc_Action_LandResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_RebootRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RebootRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_RebootRequest, rhs: Mavsdk_Rpc_Action_RebootRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_RebootResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RebootResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_RebootResponse, rhs: Mavsdk_Rpc_Action_RebootResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_ShutdownRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShutdownRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_ShutdownRequest, rhs: Mavsdk_Rpc_Action_ShutdownRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_ShutdownResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShutdownResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_ShutdownResponse, rhs: Mavsdk_Rpc_Action_ShutdownResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_TerminateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TerminateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_TerminateRequest, rhs: Mavsdk_Rpc_Action_TerminateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_TerminateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TerminateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_TerminateResponse, rhs: Mavsdk_Rpc_Action_TerminateResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_KillRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KillRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_KillRequest, rhs: Mavsdk_Rpc_Action_KillRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_KillResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KillResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_KillResponse, rhs: Mavsdk_Rpc_Action_KillResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_ReturnToLaunchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReturnToLaunchRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_ReturnToLaunchRequest, rhs: Mavsdk_Rpc_Action_ReturnToLaunchRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_ReturnToLaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReturnToLaunchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_ReturnToLaunchResponse, rhs: Mavsdk_Rpc_Action_ReturnToLaunchResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_GotoLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GotoLocationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latitude_deg"),
    2: .standard(proto: "longitude_deg"),
    3: .standard(proto: "absolute_altitude_m"),
    4: .standard(proto: "yaw_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitudeDeg) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitudeDeg) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.absoluteAltitudeM) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.yawDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.latitudeDeg, fieldNumber: 1)
    }
    if self.longitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.longitudeDeg, fieldNumber: 2)
    }
    if self.absoluteAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.absoluteAltitudeM, fieldNumber: 3)
    }
    if self.yawDeg != 0 {
      try visitor.visitSingularFloatField(value: self.yawDeg, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_GotoLocationRequest, rhs: Mavsdk_Rpc_Action_GotoLocationRequest) -> Bool {
    if lhs.latitudeDeg != rhs.latitudeDeg {return false}
    if lhs.longitudeDeg != rhs.longitudeDeg {return false}
    if lhs.absoluteAltitudeM != rhs.absoluteAltitudeM {return false}
    if lhs.yawDeg != rhs.yawDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_GotoLocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GotoLocationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_GotoLocationResponse, rhs: Mavsdk_Rpc_Action_GotoLocationResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_DoOrbitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoOrbitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radius_m"),
    2: .standard(proto: "velocity_ms"),
    3: .standard(proto: "yaw_behavior"),
    5: .standard(proto: "latitude_deg"),
    6: .standard(proto: "longitude_deg"),
    7: .standard(proto: "absolute_altitude_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.radiusM) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.velocityMs) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.yawBehavior) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.latitudeDeg) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.longitudeDeg) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.absoluteAltitudeM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.radiusM != 0 {
      try visitor.visitSingularFloatField(value: self.radiusM, fieldNumber: 1)
    }
    if self.velocityMs != 0 {
      try visitor.visitSingularFloatField(value: self.velocityMs, fieldNumber: 2)
    }
    if self.yawBehavior != .holdFrontToCircleCenter {
      try visitor.visitSingularEnumField(value: self.yawBehavior, fieldNumber: 3)
    }
    if self.latitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.latitudeDeg, fieldNumber: 5)
    }
    if self.longitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.longitudeDeg, fieldNumber: 6)
    }
    if self.absoluteAltitudeM != 0 {
      try visitor.visitSingularDoubleField(value: self.absoluteAltitudeM, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_DoOrbitRequest, rhs: Mavsdk_Rpc_Action_DoOrbitRequest) -> Bool {
    if lhs.radiusM != rhs.radiusM {return false}
    if lhs.velocityMs != rhs.velocityMs {return false}
    if lhs.yawBehavior != rhs.yawBehavior {return false}
    if lhs.latitudeDeg != rhs.latitudeDeg {return false}
    if lhs.longitudeDeg != rhs.longitudeDeg {return false}
    if lhs.absoluteAltitudeM != rhs.absoluteAltitudeM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_DoOrbitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoOrbitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_DoOrbitResponse, rhs: Mavsdk_Rpc_Action_DoOrbitResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_HoldRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HoldRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_HoldRequest, rhs: Mavsdk_Rpc_Action_HoldRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_HoldResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HoldResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_HoldResponse, rhs: Mavsdk_Rpc_Action_HoldResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_SetActuatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetActuatorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_SetActuatorRequest, rhs: Mavsdk_Rpc_Action_SetActuatorRequest) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_SetActuatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetActuatorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_SetActuatorResponse, rhs: Mavsdk_Rpc_Action_SetActuatorResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_TransitionToFixedwingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransitionToFixedwingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_TransitionToFixedwingRequest, rhs: Mavsdk_Rpc_Action_TransitionToFixedwingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_TransitionToFixedwingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransitionToFixedwingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_TransitionToFixedwingResponse, rhs: Mavsdk_Rpc_Action_TransitionToFixedwingResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_TransitionToMulticopterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransitionToMulticopterRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_TransitionToMulticopterRequest, rhs: Mavsdk_Rpc_Action_TransitionToMulticopterRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_TransitionToMulticopterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransitionToMulticopterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_TransitionToMulticopterResponse, rhs: Mavsdk_Rpc_Action_TransitionToMulticopterResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_GetTakeoffAltitudeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTakeoffAltitudeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_GetTakeoffAltitudeRequest, rhs: Mavsdk_Rpc_Action_GetTakeoffAltitudeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_GetTakeoffAltitudeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTakeoffAltitudeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
    2: .same(proto: "altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.altitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.altitude != 0 {
      try visitor.visitSingularFloatField(value: self.altitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_GetTakeoffAltitudeResponse, rhs: Mavsdk_Rpc_Action_GetTakeoffAltitudeResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_SetTakeoffAltitudeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTakeoffAltitudeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.altitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.altitude != 0 {
      try visitor.visitSingularFloatField(value: self.altitude, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_SetTakeoffAltitudeRequest, rhs: Mavsdk_Rpc_Action_SetTakeoffAltitudeRequest) -> Bool {
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_SetTakeoffAltitudeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTakeoffAltitudeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_SetTakeoffAltitudeResponse, rhs: Mavsdk_Rpc_Action_SetTakeoffAltitudeResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_GetMaximumSpeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMaximumSpeedRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_GetMaximumSpeedRequest, rhs: Mavsdk_Rpc_Action_GetMaximumSpeedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_GetMaximumSpeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMaximumSpeedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
    2: .same(proto: "speed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.speed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_GetMaximumSpeedResponse, rhs: Mavsdk_Rpc_Action_GetMaximumSpeedResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_SetMaximumSpeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetMaximumSpeedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "speed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.speed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_SetMaximumSpeedRequest, rhs: Mavsdk_Rpc_Action_SetMaximumSpeedRequest) -> Bool {
    if lhs.speed != rhs.speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_SetMaximumSpeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetMaximumSpeedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_SetMaximumSpeedResponse, rhs: Mavsdk_Rpc_Action_SetMaximumSpeedResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_GetReturnToLaunchAltitudeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReturnToLaunchAltitudeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_GetReturnToLaunchAltitudeRequest, rhs: Mavsdk_Rpc_Action_GetReturnToLaunchAltitudeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_GetReturnToLaunchAltitudeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReturnToLaunchAltitudeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
    2: .standard(proto: "relative_altitude_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.relativeAltitudeM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.relativeAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.relativeAltitudeM, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_GetReturnToLaunchAltitudeResponse, rhs: Mavsdk_Rpc_Action_GetReturnToLaunchAltitudeResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.relativeAltitudeM != rhs.relativeAltitudeM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_SetReturnToLaunchAltitudeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetReturnToLaunchAltitudeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "relative_altitude_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.relativeAltitudeM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.relativeAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.relativeAltitudeM, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_SetReturnToLaunchAltitudeRequest, rhs: Mavsdk_Rpc_Action_SetReturnToLaunchAltitudeRequest) -> Bool {
    if lhs.relativeAltitudeM != rhs.relativeAltitudeM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_SetReturnToLaunchAltitudeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetReturnToLaunchAltitudeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_SetReturnToLaunchAltitudeResponse, rhs: Mavsdk_Rpc_Action_SetReturnToLaunchAltitudeResponse) -> Bool {
    if lhs._actionResult != rhs._actionResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_ActionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_str"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resultStr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.resultStr.isEmpty {
      try visitor.visitSingularStringField(value: self.resultStr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Action_ActionResult, rhs: Mavsdk_Rpc_Action_ActionResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.resultStr != rhs.resultStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Action_ActionResult.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNKNOWN"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_NO_SYSTEM"),
    3: .same(proto: "RESULT_CONNECTION_ERROR"),
    4: .same(proto: "RESULT_BUSY"),
    5: .same(proto: "RESULT_COMMAND_DENIED"),
    6: .same(proto: "RESULT_COMMAND_DENIED_LANDED_STATE_UNKNOWN"),
    7: .same(proto: "RESULT_COMMAND_DENIED_NOT_LANDED"),
    8: .same(proto: "RESULT_TIMEOUT"),
    9: .same(proto: "RESULT_VTOL_TRANSITION_SUPPORT_UNKNOWN"),
    10: .same(proto: "RESULT_NO_VTOL_TRANSITION_SUPPORT"),
    11: .same(proto: "RESULT_PARAMETER_ERROR"),
  ]
}
