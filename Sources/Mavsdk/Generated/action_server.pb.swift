// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: action_server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Flight modes.
///
/// For more information about flight modes, check out
/// https://docs.px4.io/master/en/config/flight_mode.html.
enum Mavsdk_Rpc_ActionServer_FlightMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Mode not known
  case unknown // = 0

  /// Armed and ready to take off
  case ready // = 1

  /// Taking off
  case takeoff // = 2

  /// Holding (hovering in place (or circling for fixed-wing vehicles)
  case hold // = 3

  /// In mission
  case mission // = 4

  /// Returning to launch position (then landing)
  case returnToLaunch // = 5

  /// Landing
  case land // = 6

  /// In 'offboard' mode
  case offboard // = 7

  /// In 'follow-me' mode
  case followMe // = 8

  /// In 'Manual' mode
  case manual // = 9

  /// In 'Altitude Control' mode
  case altctl // = 10

  /// In 'Position Control' mode
  case posctl // = 11

  /// In 'Acro' mode
  case acro // = 12

  /// In 'Stabilize' mode
  case stabilized // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ready
    case 2: self = .takeoff
    case 3: self = .hold
    case 4: self = .mission
    case 5: self = .returnToLaunch
    case 6: self = .land
    case 7: self = .offboard
    case 8: self = .followMe
    case 9: self = .manual
    case 10: self = .altctl
    case 11: self = .posctl
    case 12: self = .acro
    case 13: self = .stabilized
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ready: return 1
    case .takeoff: return 2
    case .hold: return 3
    case .mission: return 4
    case .returnToLaunch: return 5
    case .land: return 6
    case .offboard: return 7
    case .followMe: return 8
    case .manual: return 9
    case .altctl: return 10
    case .posctl: return 11
    case .acro: return 12
    case .stabilized: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_ActionServer_FlightMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_ActionServer_FlightMode] = [
    .unknown,
    .ready,
    .takeoff,
    .hold,
    .mission,
    .returnToLaunch,
    .land,
    .offboard,
    .followMe,
    .manual,
    .altctl,
    .posctl,
    .acro,
    .stabilized,
  ]
}

#endif  // swift(>=4.2)

struct Mavsdk_Rpc_ActionServer_SetAllowTakeoffRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is takeoff allowed?
  var allowTakeoff: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SetArmableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is Armable now?
  var armable: Bool = false

  /// Is armable with force?
  var forceArmable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SetDisarmableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is disarmable now?
  var disarmable: Bool = false

  /// Is disarmable with force? (Kill)
  var forceDisarmable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SetAllowableFlightModesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var flightModes: Mavsdk_Rpc_ActionServer_AllowableFlightModes {
    get {return _flightModes ?? Mavsdk_Rpc_ActionServer_AllowableFlightModes()}
    set {_flightModes = newValue}
  }
  /// Returns true if `flightModes` has been explicitly set.
  var hasFlightModes: Bool {return self._flightModes != nil}
  /// Clears the value of `flightModes`. Subsequent reads from it will return its default value.
  mutating func clearFlightModes() {self._flightModes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _flightModes: Mavsdk_Rpc_ActionServer_AllowableFlightModes? = nil
}

struct Mavsdk_Rpc_ActionServer_GetAllowableFlightModesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SubscribeArmDisarmRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SubscribeFlightModeChangeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SubscribeTakeoffRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SubscribeLandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SubscribeRebootRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SubscribeShutdownRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_SubscribeTerminateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ActionServer_ArmDisarmResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var arm: Mavsdk_Rpc_ActionServer_ArmDisarm {
    get {return _arm ?? Mavsdk_Rpc_ActionServer_ArmDisarm()}
    set {_arm = newValue}
  }
  /// Returns true if `arm` has been explicitly set.
  var hasArm: Bool {return self._arm != nil}
  /// Clears the value of `arm`. Subsequent reads from it will return its default value.
  mutating func clearArm() {self._arm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
  fileprivate var _arm: Mavsdk_Rpc_ActionServer_ArmDisarm? = nil
}

struct Mavsdk_Rpc_ActionServer_FlightModeChangeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var flightMode: Mavsdk_Rpc_ActionServer_FlightMode = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_TakeoffResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var takeoff: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_LandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var land: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_RebootResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var reboot: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_ShutdownResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var shutdown: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_TerminateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var terminate: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_SetArmableResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_SetDisarmableResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_SetAllowableFlightModesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_SetAllowTakeoffResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult {
    get {return _actionServerResult ?? Mavsdk_Rpc_ActionServer_ActionServerResult()}
    set {_actionServerResult = newValue}
  }
  /// Returns true if `actionServerResult` has been explicitly set.
  var hasActionServerResult: Bool {return self._actionServerResult != nil}
  /// Clears the value of `actionServerResult`. Subsequent reads from it will return its default value.
  mutating func clearActionServerResult() {self._actionServerResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actionServerResult: Mavsdk_Rpc_ActionServer_ActionServerResult? = nil
}

struct Mavsdk_Rpc_ActionServer_GetAllowableFlightModesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var flightModes: Mavsdk_Rpc_ActionServer_AllowableFlightModes {
    get {return _flightModes ?? Mavsdk_Rpc_ActionServer_AllowableFlightModes()}
    set {_flightModes = newValue}
  }
  /// Returns true if `flightModes` has been explicitly set.
  var hasFlightModes: Bool {return self._flightModes != nil}
  /// Clears the value of `flightModes`. Subsequent reads from it will return its default value.
  mutating func clearFlightModes() {self._flightModes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _flightModes: Mavsdk_Rpc_ActionServer_AllowableFlightModes? = nil
}

/// State to check if the vehicle can transition to
/// respective flightmodes
struct Mavsdk_Rpc_ActionServer_AllowableFlightModes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Auto/mission mode 
  var canAutoMode: Bool = false

  /// Guided mode
  var canGuidedMode: Bool = false

  /// Stabilize mode
  var canStabilizeMode: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Arming message type
struct Mavsdk_Rpc_ActionServer_ArmDisarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Should vehicle arm
  var arm: Bool = false

  /// Should arm override pre-flight checks
  var force: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result type.
struct Mavsdk_Rpc_ActionServer_ActionServerResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result enum value
  var result: Mavsdk_Rpc_ActionServer_ActionServerResult.Result = .unknown

  /// Human-readable English string describing the result
  var resultStr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible results returned for action requests.
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result
    case unknown // = 0

    /// Request was successful
    case success // = 1

    /// No system is connected
    case noSystem // = 2

    /// Connection error
    case connectionError // = 3

    /// Vehicle is busy
    case busy // = 4

    /// Command refused by vehicle
    case commandDenied // = 5

    /// Command refused because landed state is unknown
    case commandDeniedLandedStateUnknown // = 6

    /// Command refused because vehicle not landed
    case commandDeniedNotLanded // = 7

    /// Request timed out
    case timeout // = 8

    /// Hybrid/VTOL transition support is unknown
    case vtolTransitionSupportUnknown // = 9

    /// Vehicle does not support hybrid/VTOL transitions
    case noVtolTransitionSupport // = 10

    /// Error getting or setting parameter
    case parameterError // = 11

    /// Intermediate message showing progress or instructions on the next steps
    case next // = 12
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .noSystem
      case 3: self = .connectionError
      case 4: self = .busy
      case 5: self = .commandDenied
      case 6: self = .commandDeniedLandedStateUnknown
      case 7: self = .commandDeniedNotLanded
      case 8: self = .timeout
      case 9: self = .vtolTransitionSupportUnknown
      case 10: self = .noVtolTransitionSupport
      case 11: self = .parameterError
      case 12: self = .next
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .noSystem: return 2
      case .connectionError: return 3
      case .busy: return 4
      case .commandDenied: return 5
      case .commandDeniedLandedStateUnknown: return 6
      case .commandDeniedNotLanded: return 7
      case .timeout: return 8
      case .vtolTransitionSupportUnknown: return 9
      case .noVtolTransitionSupport: return 10
      case .parameterError: return 11
      case .next: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mavsdk_Rpc_ActionServer_ActionServerResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_ActionServer_ActionServerResult.Result] = [
    .unknown,
    .success,
    .noSystem,
    .connectionError,
    .busy,
    .commandDenied,
    .commandDeniedLandedStateUnknown,
    .commandDeniedNotLanded,
    .timeout,
    .vtolTransitionSupportUnknown,
    .noVtolTransitionSupport,
    .parameterError,
    .next,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mavsdk.rpc.action_server"

extension Mavsdk_Rpc_ActionServer_FlightMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FLIGHT_MODE_UNKNOWN"),
    1: .same(proto: "FLIGHT_MODE_READY"),
    2: .same(proto: "FLIGHT_MODE_TAKEOFF"),
    3: .same(proto: "FLIGHT_MODE_HOLD"),
    4: .same(proto: "FLIGHT_MODE_MISSION"),
    5: .same(proto: "FLIGHT_MODE_RETURN_TO_LAUNCH"),
    6: .same(proto: "FLIGHT_MODE_LAND"),
    7: .same(proto: "FLIGHT_MODE_OFFBOARD"),
    8: .same(proto: "FLIGHT_MODE_FOLLOW_ME"),
    9: .same(proto: "FLIGHT_MODE_MANUAL"),
    10: .same(proto: "FLIGHT_MODE_ALTCTL"),
    11: .same(proto: "FLIGHT_MODE_POSCTL"),
    12: .same(proto: "FLIGHT_MODE_ACRO"),
    13: .same(proto: "FLIGHT_MODE_STABILIZED"),
  ]
}

extension Mavsdk_Rpc_ActionServer_SetAllowTakeoffRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAllowTakeoffRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_takeoff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.allowTakeoff) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.allowTakeoff != false {
      try visitor.visitSingularBoolField(value: self.allowTakeoff, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SetAllowTakeoffRequest, rhs: Mavsdk_Rpc_ActionServer_SetAllowTakeoffRequest) -> Bool {
    if lhs.allowTakeoff != rhs.allowTakeoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SetArmableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetArmableRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "armable"),
    2: .standard(proto: "force_armable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.armable) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.forceArmable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.armable != false {
      try visitor.visitSingularBoolField(value: self.armable, fieldNumber: 1)
    }
    if self.forceArmable != false {
      try visitor.visitSingularBoolField(value: self.forceArmable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SetArmableRequest, rhs: Mavsdk_Rpc_ActionServer_SetArmableRequest) -> Bool {
    if lhs.armable != rhs.armable {return false}
    if lhs.forceArmable != rhs.forceArmable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SetDisarmableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetDisarmableRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disarmable"),
    2: .standard(proto: "force_disarmable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disarmable) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.forceDisarmable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disarmable != false {
      try visitor.visitSingularBoolField(value: self.disarmable, fieldNumber: 1)
    }
    if self.forceDisarmable != false {
      try visitor.visitSingularBoolField(value: self.forceDisarmable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SetDisarmableRequest, rhs: Mavsdk_Rpc_ActionServer_SetDisarmableRequest) -> Bool {
    if lhs.disarmable != rhs.disarmable {return false}
    if lhs.forceDisarmable != rhs.forceDisarmable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SetAllowableFlightModesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAllowableFlightModesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "flight_modes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._flightModes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._flightModes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SetAllowableFlightModesRequest, rhs: Mavsdk_Rpc_ActionServer_SetAllowableFlightModesRequest) -> Bool {
    if lhs._flightModes != rhs._flightModes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_GetAllowableFlightModesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAllowableFlightModesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_GetAllowableFlightModesRequest, rhs: Mavsdk_Rpc_ActionServer_GetAllowableFlightModesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SubscribeArmDisarmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeArmDisarmRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SubscribeArmDisarmRequest, rhs: Mavsdk_Rpc_ActionServer_SubscribeArmDisarmRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SubscribeFlightModeChangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeFlightModeChangeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SubscribeFlightModeChangeRequest, rhs: Mavsdk_Rpc_ActionServer_SubscribeFlightModeChangeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SubscribeTakeoffRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeTakeoffRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SubscribeTakeoffRequest, rhs: Mavsdk_Rpc_ActionServer_SubscribeTakeoffRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SubscribeLandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeLandRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SubscribeLandRequest, rhs: Mavsdk_Rpc_ActionServer_SubscribeLandRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SubscribeRebootRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeRebootRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SubscribeRebootRequest, rhs: Mavsdk_Rpc_ActionServer_SubscribeRebootRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SubscribeShutdownRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeShutdownRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SubscribeShutdownRequest, rhs: Mavsdk_Rpc_ActionServer_SubscribeShutdownRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SubscribeTerminateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeTerminateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SubscribeTerminateRequest, rhs: Mavsdk_Rpc_ActionServer_SubscribeTerminateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_ArmDisarmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArmDisarmResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
    2: .same(proto: "arm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._arm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._arm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_ArmDisarmResponse, rhs: Mavsdk_Rpc_ActionServer_ArmDisarmResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs._arm != rhs._arm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_FlightModeChangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlightModeChangeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
    2: .standard(proto: "flight_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.flightMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.flightMode != .unknown {
      try visitor.visitSingularEnumField(value: self.flightMode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_FlightModeChangeResponse, rhs: Mavsdk_Rpc_ActionServer_FlightModeChangeResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.flightMode != rhs.flightMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_TakeoffResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TakeoffResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
    2: .same(proto: "takeoff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.takeoff) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.takeoff != false {
      try visitor.visitSingularBoolField(value: self.takeoff, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_TakeoffResponse, rhs: Mavsdk_Rpc_ActionServer_TakeoffResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.takeoff != rhs.takeoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_LandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LandResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
    2: .same(proto: "land"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.land) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.land != false {
      try visitor.visitSingularBoolField(value: self.land, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_LandResponse, rhs: Mavsdk_Rpc_ActionServer_LandResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.land != rhs.land {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_RebootResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RebootResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
    2: .same(proto: "reboot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.reboot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.reboot != false {
      try visitor.visitSingularBoolField(value: self.reboot, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_RebootResponse, rhs: Mavsdk_Rpc_ActionServer_RebootResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.reboot != rhs.reboot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_ShutdownResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShutdownResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
    2: .same(proto: "shutdown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.shutdown) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.shutdown != false {
      try visitor.visitSingularBoolField(value: self.shutdown, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_ShutdownResponse, rhs: Mavsdk_Rpc_ActionServer_ShutdownResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.shutdown != rhs.shutdown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_TerminateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TerminateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
    2: .same(proto: "terminate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.terminate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.terminate != false {
      try visitor.visitSingularBoolField(value: self.terminate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_TerminateResponse, rhs: Mavsdk_Rpc_ActionServer_TerminateResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.terminate != rhs.terminate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SetArmableResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetArmableResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SetArmableResponse, rhs: Mavsdk_Rpc_ActionServer_SetArmableResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SetDisarmableResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetDisarmableResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SetDisarmableResponse, rhs: Mavsdk_Rpc_ActionServer_SetDisarmableResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SetAllowableFlightModesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAllowableFlightModesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SetAllowableFlightModesResponse, rhs: Mavsdk_Rpc_ActionServer_SetAllowableFlightModesResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_SetAllowTakeoffResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAllowTakeoffResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_server_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionServerResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_SetAllowTakeoffResponse, rhs: Mavsdk_Rpc_ActionServer_SetAllowTakeoffResponse) -> Bool {
    if lhs._actionServerResult != rhs._actionServerResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_GetAllowableFlightModesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAllowableFlightModesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "flight_modes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._flightModes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._flightModes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_GetAllowableFlightModesResponse, rhs: Mavsdk_Rpc_ActionServer_GetAllowableFlightModesResponse) -> Bool {
    if lhs._flightModes != rhs._flightModes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_AllowableFlightModes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowableFlightModes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_auto_mode"),
    2: .standard(proto: "can_guided_mode"),
    3: .standard(proto: "can_stabilize_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canAutoMode) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canGuidedMode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canStabilizeMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canAutoMode != false {
      try visitor.visitSingularBoolField(value: self.canAutoMode, fieldNumber: 1)
    }
    if self.canGuidedMode != false {
      try visitor.visitSingularBoolField(value: self.canGuidedMode, fieldNumber: 2)
    }
    if self.canStabilizeMode != false {
      try visitor.visitSingularBoolField(value: self.canStabilizeMode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_AllowableFlightModes, rhs: Mavsdk_Rpc_ActionServer_AllowableFlightModes) -> Bool {
    if lhs.canAutoMode != rhs.canAutoMode {return false}
    if lhs.canGuidedMode != rhs.canGuidedMode {return false}
    if lhs.canStabilizeMode != rhs.canStabilizeMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_ArmDisarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArmDisarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arm"),
    2: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.arm) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.arm != false {
      try visitor.visitSingularBoolField(value: self.arm, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_ArmDisarm, rhs: Mavsdk_Rpc_ActionServer_ArmDisarm) -> Bool {
    if lhs.arm != rhs.arm {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_ActionServerResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionServerResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_str"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resultStr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.resultStr.isEmpty {
      try visitor.visitSingularStringField(value: self.resultStr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ActionServer_ActionServerResult, rhs: Mavsdk_Rpc_ActionServer_ActionServerResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.resultStr != rhs.resultStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ActionServer_ActionServerResult.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNKNOWN"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_NO_SYSTEM"),
    3: .same(proto: "RESULT_CONNECTION_ERROR"),
    4: .same(proto: "RESULT_BUSY"),
    5: .same(proto: "RESULT_COMMAND_DENIED"),
    6: .same(proto: "RESULT_COMMAND_DENIED_LANDED_STATE_UNKNOWN"),
    7: .same(proto: "RESULT_COMMAND_DENIED_NOT_LANDED"),
    8: .same(proto: "RESULT_TIMEOUT"),
    9: .same(proto: "RESULT_VTOL_TRANSITION_SUPPORT_UNKNOWN"),
    10: .same(proto: "RESULT_NO_VTOL_TRANSITION_SUPPORT"),
    11: .same(proto: "RESULT_PARAMETER_ERROR"),
    12: .same(proto: "RESULT_NEXT"),
  ]
}
