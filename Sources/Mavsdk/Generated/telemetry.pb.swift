// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: telemetry.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GPS fix type.
enum Mavsdk_Rpc_Telemetry_FixType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No GPS connected
  case noGps // = 0

  /// No position information, GPS is connected
  case noFix // = 1

  /// 2D position
  case fix2D // = 2

  /// 3D position
  case fix3D // = 3

  /// DGPS/SBAS aided 3D position
  case fixDgps // = 4

  /// RTK float, 3D position
  case rtkFloat // = 5

  /// RTK Fixed, 3D position
  case rtkFixed // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .noGps
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noGps
    case 1: self = .noFix
    case 2: self = .fix2D
    case 3: self = .fix3D
    case 4: self = .fixDgps
    case 5: self = .rtkFloat
    case 6: self = .rtkFixed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noGps: return 0
    case .noFix: return 1
    case .fix2D: return 2
    case .fix3D: return 3
    case .fixDgps: return 4
    case .rtkFloat: return 5
    case .rtkFixed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Telemetry_FixType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Telemetry_FixType] = [
    .noGps,
    .noFix,
    .fix2D,
    .fix3D,
    .fixDgps,
    .rtkFloat,
    .rtkFixed,
  ]
}

#endif  // swift(>=4.2)

///
/// Flight modes.
///
/// For more information about flight modes, check out
/// https://docs.px4.io/master/en/config/flight_mode.html.
enum Mavsdk_Rpc_Telemetry_FlightMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Mode not known
  case unknown // = 0

  /// Armed and ready to take off
  case ready // = 1

  /// Taking off
  case takeoff // = 2

  /// Holding (hovering in place (or circling for fixed-wing vehicles)
  case hold // = 3

  /// In mission
  case mission // = 4

  /// Returning to launch position (then landing)
  case returnToLaunch // = 5

  /// Landing
  case land // = 6

  /// In 'offboard' mode
  case offboard // = 7

  /// In 'follow-me' mode
  case followMe // = 8

  /// In 'Manual' mode
  case manual // = 9

  /// In 'Altitude Control' mode
  case altctl // = 10

  /// In 'Position Control' mode
  case posctl // = 11

  /// In 'Acro' mode
  case acro // = 12

  /// In 'Stabilize' mode
  case stabilized // = 13

  /// In 'Rattitude' mode
  case rattitude // = 14
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ready
    case 2: self = .takeoff
    case 3: self = .hold
    case 4: self = .mission
    case 5: self = .returnToLaunch
    case 6: self = .land
    case 7: self = .offboard
    case 8: self = .followMe
    case 9: self = .manual
    case 10: self = .altctl
    case 11: self = .posctl
    case 12: self = .acro
    case 13: self = .stabilized
    case 14: self = .rattitude
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ready: return 1
    case .takeoff: return 2
    case .hold: return 3
    case .mission: return 4
    case .returnToLaunch: return 5
    case .land: return 6
    case .offboard: return 7
    case .followMe: return 8
    case .manual: return 9
    case .altctl: return 10
    case .posctl: return 11
    case .acro: return 12
    case .stabilized: return 13
    case .rattitude: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Telemetry_FlightMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Telemetry_FlightMode] = [
    .unknown,
    .ready,
    .takeoff,
    .hold,
    .mission,
    .returnToLaunch,
    .land,
    .offboard,
    .followMe,
    .manual,
    .altctl,
    .posctl,
    .acro,
    .stabilized,
    .rattitude,
  ]
}

#endif  // swift(>=4.2)

/// Status types.
enum Mavsdk_Rpc_Telemetry_StatusTextType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Debug
  case debug // = 0

  /// Information
  case info // = 1

  /// Notice
  case notice // = 2

  /// Warning
  case warning // = 3

  /// Error
  case error // = 4

  /// Critical
  case critical // = 5

  /// Alert
  case alert // = 6

  /// Emergency
  case emergency // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .debug
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .debug
    case 1: self = .info
    case 2: self = .notice
    case 3: self = .warning
    case 4: self = .error
    case 5: self = .critical
    case 6: self = .alert
    case 7: self = .emergency
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .debug: return 0
    case .info: return 1
    case .notice: return 2
    case .warning: return 3
    case .error: return 4
    case .critical: return 5
    case .alert: return 6
    case .emergency: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Telemetry_StatusTextType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Telemetry_StatusTextType] = [
    .debug,
    .info,
    .notice,
    .warning,
    .error,
    .critical,
    .alert,
    .emergency,
  ]
}

#endif  // swift(>=4.2)

/// Landed State enumeration.
enum Mavsdk_Rpc_Telemetry_LandedState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Landed state is unknown
  case unknown // = 0

  /// The vehicle is on the ground
  case onGround // = 1

  /// The vehicle is in the air
  case inAir // = 2

  /// The vehicle is taking off
  case takingOff // = 3

  /// The vehicle is landing
  case landing // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .onGround
    case 2: self = .inAir
    case 3: self = .takingOff
    case 4: self = .landing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .onGround: return 1
    case .inAir: return 2
    case .takingOff: return 3
    case .landing: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Telemetry_LandedState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Telemetry_LandedState] = [
    .unknown,
    .onGround,
    .inAir,
    .takingOff,
    .landing,
  ]
}

#endif  // swift(>=4.2)

/// VTOL State enumeration
enum Mavsdk_Rpc_Telemetry_VtolState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// MAV is not configured as VTOL
  case undefined // = 0

  /// VTOL is in transition from multicopter to fixed-wing
  case transitionToFw // = 1

  /// VTOL is in transition from fixed-wing to multicopter
  case transitionToMc // = 2

  /// VTOL is in multicopter state
  case mc // = 3

  /// VTOL is in fixed-wing state
  case fw // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .transitionToFw
    case 2: self = .transitionToMc
    case 3: self = .mc
    case 4: self = .fw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .transitionToFw: return 1
    case .transitionToMc: return 2
    case .mc: return 3
    case .fw: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Telemetry_VtolState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Telemetry_VtolState] = [
    .undefined,
    .transitionToFw,
    .transitionToMc,
    .mc,
    .fw,
  ]
}

#endif  // swift(>=4.2)

struct Mavsdk_Rpc_Telemetry_SubscribePositionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_PositionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next position
  var position: Mavsdk_Rpc_Telemetry_Position {
    get {return _position ?? Mavsdk_Rpc_Telemetry_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Mavsdk_Rpc_Telemetry_Position? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeHomeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_HomeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next home position
  var home: Mavsdk_Rpc_Telemetry_Position {
    get {return _home ?? Mavsdk_Rpc_Telemetry_Position()}
    set {_home = newValue}
  }
  /// Returns true if `home` has been explicitly set.
  var hasHome: Bool {return self._home != nil}
  /// Clears the value of `home`. Subsequent reads from it will return its default value.
  mutating func clearHome() {self._home = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _home: Mavsdk_Rpc_Telemetry_Position? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeInAirRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_InAirResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'in-air' state
  var isInAir: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SubscribeLandedStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_LandedStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'landed' state
  var landedState: Mavsdk_Rpc_Telemetry_LandedState = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SubscribeArmedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_ArmedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'armed' state
  var isArmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SubscribeVtolStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_VtolStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'vtol' state
  var vtolState: Mavsdk_Rpc_Telemetry_VtolState = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SubscribeAttitudeQuaternionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_AttitudeQuaternionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next attitude (quaternion)
  var attitudeQuaternion: Mavsdk_Rpc_Telemetry_Quaternion {
    get {return _attitudeQuaternion ?? Mavsdk_Rpc_Telemetry_Quaternion()}
    set {_attitudeQuaternion = newValue}
  }
  /// Returns true if `attitudeQuaternion` has been explicitly set.
  var hasAttitudeQuaternion: Bool {return self._attitudeQuaternion != nil}
  /// Clears the value of `attitudeQuaternion`. Subsequent reads from it will return its default value.
  mutating func clearAttitudeQuaternion() {self._attitudeQuaternion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attitudeQuaternion: Mavsdk_Rpc_Telemetry_Quaternion? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeAttitudeEulerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_AttitudeEulerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next attitude (Euler)
  var attitudeEuler: Mavsdk_Rpc_Telemetry_EulerAngle {
    get {return _attitudeEuler ?? Mavsdk_Rpc_Telemetry_EulerAngle()}
    set {_attitudeEuler = newValue}
  }
  /// Returns true if `attitudeEuler` has been explicitly set.
  var hasAttitudeEuler: Bool {return self._attitudeEuler != nil}
  /// Clears the value of `attitudeEuler`. Subsequent reads from it will return its default value.
  mutating func clearAttitudeEuler() {self._attitudeEuler = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attitudeEuler: Mavsdk_Rpc_Telemetry_EulerAngle? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeAttitudeAngularVelocityBodyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_AttitudeAngularVelocityBodyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next angular velocity (rad/s)
  var attitudeAngularVelocityBody: Mavsdk_Rpc_Telemetry_AngularVelocityBody {
    get {return _attitudeAngularVelocityBody ?? Mavsdk_Rpc_Telemetry_AngularVelocityBody()}
    set {_attitudeAngularVelocityBody = newValue}
  }
  /// Returns true if `attitudeAngularVelocityBody` has been explicitly set.
  var hasAttitudeAngularVelocityBody: Bool {return self._attitudeAngularVelocityBody != nil}
  /// Clears the value of `attitudeAngularVelocityBody`. Subsequent reads from it will return its default value.
  mutating func clearAttitudeAngularVelocityBody() {self._attitudeAngularVelocityBody = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attitudeAngularVelocityBody: Mavsdk_Rpc_Telemetry_AngularVelocityBody? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeCameraAttitudeQuaternionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_CameraAttitudeQuaternionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next camera attitude (quaternion)
  var attitudeQuaternion: Mavsdk_Rpc_Telemetry_Quaternion {
    get {return _attitudeQuaternion ?? Mavsdk_Rpc_Telemetry_Quaternion()}
    set {_attitudeQuaternion = newValue}
  }
  /// Returns true if `attitudeQuaternion` has been explicitly set.
  var hasAttitudeQuaternion: Bool {return self._attitudeQuaternion != nil}
  /// Clears the value of `attitudeQuaternion`. Subsequent reads from it will return its default value.
  mutating func clearAttitudeQuaternion() {self._attitudeQuaternion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attitudeQuaternion: Mavsdk_Rpc_Telemetry_Quaternion? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeCameraAttitudeEulerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_CameraAttitudeEulerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next camera attitude (Euler)
  var attitudeEuler: Mavsdk_Rpc_Telemetry_EulerAngle {
    get {return _attitudeEuler ?? Mavsdk_Rpc_Telemetry_EulerAngle()}
    set {_attitudeEuler = newValue}
  }
  /// Returns true if `attitudeEuler` has been explicitly set.
  var hasAttitudeEuler: Bool {return self._attitudeEuler != nil}
  /// Clears the value of `attitudeEuler`. Subsequent reads from it will return its default value.
  mutating func clearAttitudeEuler() {self._attitudeEuler = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attitudeEuler: Mavsdk_Rpc_Telemetry_EulerAngle? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeVelocityNedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_VelocityNedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next velocity (NED)
  var velocityNed: Mavsdk_Rpc_Telemetry_VelocityNed {
    get {return _velocityNed ?? Mavsdk_Rpc_Telemetry_VelocityNed()}
    set {_velocityNed = newValue}
  }
  /// Returns true if `velocityNed` has been explicitly set.
  var hasVelocityNed: Bool {return self._velocityNed != nil}
  /// Clears the value of `velocityNed`. Subsequent reads from it will return its default value.
  mutating func clearVelocityNed() {self._velocityNed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _velocityNed: Mavsdk_Rpc_Telemetry_VelocityNed? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeGpsInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_GpsInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'GPS info' state
  var gpsInfo: Mavsdk_Rpc_Telemetry_GpsInfo {
    get {return _gpsInfo ?? Mavsdk_Rpc_Telemetry_GpsInfo()}
    set {_gpsInfo = newValue}
  }
  /// Returns true if `gpsInfo` has been explicitly set.
  var hasGpsInfo: Bool {return self._gpsInfo != nil}
  /// Clears the value of `gpsInfo`. Subsequent reads from it will return its default value.
  mutating func clearGpsInfo() {self._gpsInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gpsInfo: Mavsdk_Rpc_Telemetry_GpsInfo? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeRawGpsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_RawGpsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'Raw GPS' state. Warning: this is an advanced feature, use `Position` updates to get the location of the drone!
  var rawGps: Mavsdk_Rpc_Telemetry_RawGps {
    get {return _rawGps ?? Mavsdk_Rpc_Telemetry_RawGps()}
    set {_rawGps = newValue}
  }
  /// Returns true if `rawGps` has been explicitly set.
  var hasRawGps: Bool {return self._rawGps != nil}
  /// Clears the value of `rawGps`. Subsequent reads from it will return its default value.
  mutating func clearRawGps() {self._rawGps = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rawGps: Mavsdk_Rpc_Telemetry_RawGps? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeBatteryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_BatteryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'battery' state
  var battery: Mavsdk_Rpc_Telemetry_Battery {
    get {return _battery ?? Mavsdk_Rpc_Telemetry_Battery()}
    set {_battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return self._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {self._battery = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _battery: Mavsdk_Rpc_Telemetry_Battery? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeFlightModeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_FlightModeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next flight mode
  var flightMode: Mavsdk_Rpc_Telemetry_FlightMode = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SubscribeHealthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_HealthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'health' state
  var health: Mavsdk_Rpc_Telemetry_Health {
    get {return _health ?? Mavsdk_Rpc_Telemetry_Health()}
    set {_health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return self._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {self._health = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _health: Mavsdk_Rpc_Telemetry_Health? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeRcStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_RcStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next RC status
  var rcStatus: Mavsdk_Rpc_Telemetry_RcStatus {
    get {return _rcStatus ?? Mavsdk_Rpc_Telemetry_RcStatus()}
    set {_rcStatus = newValue}
  }
  /// Returns true if `rcStatus` has been explicitly set.
  var hasRcStatus: Bool {return self._rcStatus != nil}
  /// Clears the value of `rcStatus`. Subsequent reads from it will return its default value.
  mutating func clearRcStatus() {self._rcStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rcStatus: Mavsdk_Rpc_Telemetry_RcStatus? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeStatusTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_StatusTextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'status text'
  var statusText: Mavsdk_Rpc_Telemetry_StatusText {
    get {return _statusText ?? Mavsdk_Rpc_Telemetry_StatusText()}
    set {_statusText = newValue}
  }
  /// Returns true if `statusText` has been explicitly set.
  var hasStatusText: Bool {return self._statusText != nil}
  /// Clears the value of `statusText`. Subsequent reads from it will return its default value.
  mutating func clearStatusText() {self._statusText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _statusText: Mavsdk_Rpc_Telemetry_StatusText? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeActuatorControlTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_ActuatorControlTargetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next actuator control target
  var actuatorControlTarget: Mavsdk_Rpc_Telemetry_ActuatorControlTarget {
    get {return _actuatorControlTarget ?? Mavsdk_Rpc_Telemetry_ActuatorControlTarget()}
    set {_actuatorControlTarget = newValue}
  }
  /// Returns true if `actuatorControlTarget` has been explicitly set.
  var hasActuatorControlTarget: Bool {return self._actuatorControlTarget != nil}
  /// Clears the value of `actuatorControlTarget`. Subsequent reads from it will return its default value.
  mutating func clearActuatorControlTarget() {self._actuatorControlTarget = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actuatorControlTarget: Mavsdk_Rpc_Telemetry_ActuatorControlTarget? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeActuatorOutputStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_ActuatorOutputStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next actuator output status
  var actuatorOutputStatus: Mavsdk_Rpc_Telemetry_ActuatorOutputStatus {
    get {return _actuatorOutputStatus ?? Mavsdk_Rpc_Telemetry_ActuatorOutputStatus()}
    set {_actuatorOutputStatus = newValue}
  }
  /// Returns true if `actuatorOutputStatus` has been explicitly set.
  var hasActuatorOutputStatus: Bool {return self._actuatorOutputStatus != nil}
  /// Clears the value of `actuatorOutputStatus`. Subsequent reads from it will return its default value.
  mutating func clearActuatorOutputStatus() {self._actuatorOutputStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actuatorOutputStatus: Mavsdk_Rpc_Telemetry_ActuatorOutputStatus? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeOdometryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_OdometryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next odometry status
  var odometry: Mavsdk_Rpc_Telemetry_Odometry {
    get {return _odometry ?? Mavsdk_Rpc_Telemetry_Odometry()}
    set {_odometry = newValue}
  }
  /// Returns true if `odometry` has been explicitly set.
  var hasOdometry: Bool {return self._odometry != nil}
  /// Clears the value of `odometry`. Subsequent reads from it will return its default value.
  mutating func clearOdometry() {self._odometry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _odometry: Mavsdk_Rpc_Telemetry_Odometry? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribePositionVelocityNedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_PositionVelocityNedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next position and velocity status
  var positionVelocityNed: Mavsdk_Rpc_Telemetry_PositionVelocityNed {
    get {return _positionVelocityNed ?? Mavsdk_Rpc_Telemetry_PositionVelocityNed()}
    set {_positionVelocityNed = newValue}
  }
  /// Returns true if `positionVelocityNed` has been explicitly set.
  var hasPositionVelocityNed: Bool {return self._positionVelocityNed != nil}
  /// Clears the value of `positionVelocityNed`. Subsequent reads from it will return its default value.
  mutating func clearPositionVelocityNed() {self._positionVelocityNed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionVelocityNed: Mavsdk_Rpc_Telemetry_PositionVelocityNed? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeGroundTruthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_GroundTruthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ground truth position information available in simulation
  var groundTruth: Mavsdk_Rpc_Telemetry_GroundTruth {
    get {return _groundTruth ?? Mavsdk_Rpc_Telemetry_GroundTruth()}
    set {_groundTruth = newValue}
  }
  /// Returns true if `groundTruth` has been explicitly set.
  var hasGroundTruth: Bool {return self._groundTruth != nil}
  /// Clears the value of `groundTruth`. Subsequent reads from it will return its default value.
  mutating func clearGroundTruth() {self._groundTruth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groundTruth: Mavsdk_Rpc_Telemetry_GroundTruth? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeFixedwingMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_FixedwingMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next fixedwing metrics
  var fixedwingMetrics: Mavsdk_Rpc_Telemetry_FixedwingMetrics {
    get {return _fixedwingMetrics ?? Mavsdk_Rpc_Telemetry_FixedwingMetrics()}
    set {_fixedwingMetrics = newValue}
  }
  /// Returns true if `fixedwingMetrics` has been explicitly set.
  var hasFixedwingMetrics: Bool {return self._fixedwingMetrics != nil}
  /// Clears the value of `fixedwingMetrics`. Subsequent reads from it will return its default value.
  mutating func clearFixedwingMetrics() {self._fixedwingMetrics = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fixedwingMetrics: Mavsdk_Rpc_Telemetry_FixedwingMetrics? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeImuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_ImuResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next IMU status
  var imu: Mavsdk_Rpc_Telemetry_Imu {
    get {return _imu ?? Mavsdk_Rpc_Telemetry_Imu()}
    set {_imu = newValue}
  }
  /// Returns true if `imu` has been explicitly set.
  var hasImu: Bool {return self._imu != nil}
  /// Clears the value of `imu`. Subsequent reads from it will return its default value.
  mutating func clearImu() {self._imu = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _imu: Mavsdk_Rpc_Telemetry_Imu? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeScaledImuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_ScaledImuResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next scaled IMU status
  var imu: Mavsdk_Rpc_Telemetry_Imu {
    get {return _imu ?? Mavsdk_Rpc_Telemetry_Imu()}
    set {_imu = newValue}
  }
  /// Returns true if `imu` has been explicitly set.
  var hasImu: Bool {return self._imu != nil}
  /// Clears the value of `imu`. Subsequent reads from it will return its default value.
  mutating func clearImu() {self._imu = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _imu: Mavsdk_Rpc_Telemetry_Imu? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeRawImuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_RawImuResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next raw IMU status
  var imu: Mavsdk_Rpc_Telemetry_Imu {
    get {return _imu ?? Mavsdk_Rpc_Telemetry_Imu()}
    set {_imu = newValue}
  }
  /// Returns true if `imu` has been explicitly set.
  var hasImu: Bool {return self._imu != nil}
  /// Clears the value of `imu`. Subsequent reads from it will return its default value.
  mutating func clearImu() {self._imu = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _imu: Mavsdk_Rpc_Telemetry_Imu? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeHealthAllOkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_HealthAllOkResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'health all ok' status
  var isHealthAllOk: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SubscribeUnixEpochTimeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_UnixEpochTimeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next 'unix epoch time' status
  var timeUs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SubscribeDistanceSensorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_DistanceSensorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next Distance Sensor status
  var distanceSensor: Mavsdk_Rpc_Telemetry_DistanceSensor {
    get {return _distanceSensor ?? Mavsdk_Rpc_Telemetry_DistanceSensor()}
    set {_distanceSensor = newValue}
  }
  /// Returns true if `distanceSensor` has been explicitly set.
  var hasDistanceSensor: Bool {return self._distanceSensor != nil}
  /// Clears the value of `distanceSensor`. Subsequent reads from it will return its default value.
  mutating func clearDistanceSensor() {self._distanceSensor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _distanceSensor: Mavsdk_Rpc_Telemetry_DistanceSensor? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeScaledPressureRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_ScaledPressureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next Scaled Pressure status
  var scaledPressure: Mavsdk_Rpc_Telemetry_ScaledPressure {
    get {return _scaledPressure ?? Mavsdk_Rpc_Telemetry_ScaledPressure()}
    set {_scaledPressure = newValue}
  }
  /// Returns true if `scaledPressure` has been explicitly set.
  var hasScaledPressure: Bool {return self._scaledPressure != nil}
  /// Clears the value of `scaledPressure`. Subsequent reads from it will return its default value.
  mutating func clearScaledPressure() {self._scaledPressure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scaledPressure: Mavsdk_Rpc_Telemetry_ScaledPressure? = nil
}

struct Mavsdk_Rpc_Telemetry_SubscribeHeadingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_HeadingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next heading (yaw) in degrees
  var headingDeg: Mavsdk_Rpc_Telemetry_Heading {
    get {return _headingDeg ?? Mavsdk_Rpc_Telemetry_Heading()}
    set {_headingDeg = newValue}
  }
  /// Returns true if `headingDeg` has been explicitly set.
  var hasHeadingDeg: Bool {return self._headingDeg != nil}
  /// Clears the value of `headingDeg`. Subsequent reads from it will return its default value.
  mutating func clearHeadingDeg() {self._headingDeg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _headingDeg: Mavsdk_Rpc_Telemetry_Heading? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRatePositionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRatePositionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateHomeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateHomeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateInAirRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateInAirResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateLandedStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateLandedStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateVtolStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateVtolStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateAttitudeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateAttitudeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateAttitudeAngularVelocityBodyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateAttitudeAngularVelocityBodyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeQuaternionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeQuaternionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateVelocityNedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateVelocityNedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateGpsInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateGpsInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateRawGpsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateBatteryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateBatteryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateRcStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateRcStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateActuatorControlTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateActuatorControlTargetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateActuatorOutputStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateActuatorOutputStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateOdometryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateOdometryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRatePositionVelocityNedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRatePositionVelocityNedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateGroundTruthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateGroundTruthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateFixedwingMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateFixedwingMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateImuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateImuResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateScaledImuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateScaledImuResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateRawImuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateRawImuResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateUnixEpochTimeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateUnixEpochTimeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_SetRateDistanceSensorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested rate (in Hertz)
  var rateHz: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_SetRateDistanceSensorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
}

struct Mavsdk_Rpc_Telemetry_GetGpsGlobalOriginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Telemetry_GetGpsGlobalOriginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult {
    get {return _telemetryResult ?? Mavsdk_Rpc_Telemetry_TelemetryResult()}
    set {_telemetryResult = newValue}
  }
  /// Returns true if `telemetryResult` has been explicitly set.
  var hasTelemetryResult: Bool {return self._telemetryResult != nil}
  /// Clears the value of `telemetryResult`. Subsequent reads from it will return its default value.
  mutating func clearTelemetryResult() {self._telemetryResult = nil}

  var gpsGlobalOrigin: Mavsdk_Rpc_Telemetry_GpsGlobalOrigin {
    get {return _gpsGlobalOrigin ?? Mavsdk_Rpc_Telemetry_GpsGlobalOrigin()}
    set {_gpsGlobalOrigin = newValue}
  }
  /// Returns true if `gpsGlobalOrigin` has been explicitly set.
  var hasGpsGlobalOrigin: Bool {return self._gpsGlobalOrigin != nil}
  /// Clears the value of `gpsGlobalOrigin`. Subsequent reads from it will return its default value.
  mutating func clearGpsGlobalOrigin() {self._gpsGlobalOrigin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _telemetryResult: Mavsdk_Rpc_Telemetry_TelemetryResult? = nil
  fileprivate var _gpsGlobalOrigin: Mavsdk_Rpc_Telemetry_GpsGlobalOrigin? = nil
}

/// Position type in global coordinates.
struct Mavsdk_Rpc_Telemetry_Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Latitude in degrees (range: -90 to +90)
  var latitudeDeg: Double = 0

  /// Longitude in degrees (range: -180 to +180)
  var longitudeDeg: Double = 0

  /// Altitude AMSL (above mean sea level) in metres
  var absoluteAltitudeM: Float = 0

  /// Altitude relative to takeoff altitude in metres
  var relativeAltitudeM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Heading type used for global position
struct Mavsdk_Rpc_Telemetry_Heading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Heading in degrees (range: 0 to +360)
  var headingDeg: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Quaternion type.
///
/// All rotations and axis systems follow the right-hand rule.
/// The Hamilton quaternion product definition is used.
/// A zero-rotation quaternion is represented by (1,0,0,0).
/// The quaternion could also be written as w + xi + yj + zk.
///
/// For more info see: https://en.wikipedia.org/wiki/Quaternion
struct Mavsdk_Rpc_Telemetry_Quaternion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Quaternion entry 0, also denoted as a
  var w: Float = 0

  /// Quaternion entry 1, also denoted as b
  var x: Float = 0

  /// Quaternion entry 2, also denoted as c
  var y: Float = 0

  /// Quaternion entry 3, also denoted as d
  var z: Float = 0

  /// Timestamp in microseconds
  var timestampUs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Euler angle type.
///
/// All rotations and axis systems follow the right-hand rule.
/// The Euler angles follow the convention of a 3-2-1 intrinsic Tait-Bryan rotation sequence.
///
/// For more info see https://en.wikipedia.org/wiki/Euler_angles
struct Mavsdk_Rpc_Telemetry_EulerAngle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roll angle in degrees, positive is banking to the right
  var rollDeg: Float = 0

  /// Pitch angle in degrees, positive is pitching nose up
  var pitchDeg: Float = 0

  /// Yaw angle in degrees, positive is clock-wise seen from above
  var yawDeg: Float = 0

  /// Timestamp in microseconds
  var timestampUs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Angular velocity type.
struct Mavsdk_Rpc_Telemetry_AngularVelocityBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roll angular velocity
  var rollRadS: Float = 0

  /// Pitch angular velocity
  var pitchRadS: Float = 0

  /// Yaw angular velocity
  var yawRadS: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GPS information type.
struct Mavsdk_Rpc_Telemetry_GpsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of visible satellites in use
  var numSatellites: Int32 = 0

  /// Fix type
  var fixType: Mavsdk_Rpc_Telemetry_FixType = .noGps

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Raw GPS information type.
///
/// Warning: this is an advanced type! If you want the location of the drone, use
/// the position instead. This message exposes the raw values of the GNSS sensor.
struct Mavsdk_Rpc_Telemetry_RawGps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in microseconds (UNIX Epoch time or time since system boot, to be inferred)
  var timestampUs: UInt64 = 0

  /// Latitude in degrees (WGS84, EGM96 ellipsoid)
  var latitudeDeg: Double = 0

  /// Longitude in degrees (WGS84, EGM96 ellipsoid)
  var longitudeDeg: Double = 0

  /// Altitude AMSL (above mean sea level) in metres
  var absoluteAltitudeM: Float = 0

  /// GPS HDOP horizontal dilution of position (unitless). If unknown, set to NaN
  var hdop: Float = 0

  /// GPS VDOP vertical dilution of position (unitless). If unknown, set to NaN
  var vdop: Float = 0

  /// Ground velocity in metres per second
  var velocityMS: Float = 0

  /// Course over ground (NOT heading, but direction of movement) in degrees. If unknown, set to NaN
  var cogDeg: Float = 0

  /// Altitude in metres (above WGS84, EGM96 ellipsoid)
  var altitudeEllipsoidM: Float = 0

  /// Position uncertainty in metres
  var horizontalUncertaintyM: Float = 0

  /// Altitude uncertainty in metres
  var verticalUncertaintyM: Float = 0

  /// Velocity uncertainty in metres per second
  var velocityUncertaintyMS: Float = 0

  /// Heading uncertainty in degrees
  var headingUncertaintyDeg: Float = 0

  /// Yaw in earth frame from north.
  var yawDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Battery type.
struct Mavsdk_Rpc_Telemetry_Battery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Battery ID, for systems with multiple batteries
  var id: UInt32 = 0

  /// Voltage in volts
  var voltageV: Float = 0

  /// Estimated battery remaining (range: 0.0 to 1.0)
  var remainingPercent: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Health type.
struct Mavsdk_Rpc_Telemetry_Health {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if the gyrometer is calibrated
  var isGyrometerCalibrationOk: Bool = false

  /// True if the accelerometer is calibrated
  var isAccelerometerCalibrationOk: Bool = false

  /// True if the magnetometer is calibrated
  var isMagnetometerCalibrationOk: Bool = false

  /// True if the local position estimate is good enough to fly in 'position control' mode
  var isLocalPositionOk: Bool = false

  /// True if the global position estimate is good enough to fly in 'position control' mode
  var isGlobalPositionOk: Bool = false

  /// True if the home position has been initialized properly
  var isHomePositionOk: Bool = false

  /// True if system can be armed
  var isArmable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Remote control status type.
struct Mavsdk_Rpc_Telemetry_RcStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if an RC signal has been available once
  var wasAvailableOnce: Bool = false

  /// True if the RC signal is available now
  var isAvailable: Bool = false

  /// Signal strength (range: 0 to 100, NaN if unknown)
  var signalStrengthPercent: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// StatusText information type.
struct Mavsdk_Rpc_Telemetry_StatusText {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message type
  var type: Mavsdk_Rpc_Telemetry_StatusTextType = .debug

  /// MAVLink status message
  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Actuator control target type.
struct Mavsdk_Rpc_Telemetry_ActuatorControlTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An actuator control group is e.g. 'attitude' for the core flight controls, or 'gimbal' for a payload.
  var group: Int32 = 0

  /// Controls normed from -1 to 1, where 0 is neutral position.
  var controls: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Actuator output status type.
struct Mavsdk_Rpc_Telemetry_ActuatorOutputStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Active outputs
  var active: UInt32 = 0

  /// Servo/motor output values
  var actuator: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Covariance type.
///
/// Row-major representation of a 6x6 cross-covariance matrix
/// upper right triangle.
/// Set first to NaN if unknown.
struct Mavsdk_Rpc_Telemetry_Covariance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Representation of a covariance matrix.
  var covarianceMatrix: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Velocity type, represented in the Body (X Y Z) frame and in metres/second.
struct Mavsdk_Rpc_Telemetry_VelocityBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Velocity in X in metres/second
  var xMS: Float = 0

  /// Velocity in Y in metres/second
  var yMS: Float = 0

  /// Velocity in Z in metres/second
  var zMS: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Position type, represented in the Body (X Y Z) frame
struct Mavsdk_Rpc_Telemetry_PositionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// X Position in metres.
  var xM: Float = 0

  /// Y Position in metres.
  var yM: Float = 0

  /// Z Position in metres.
  var zM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Odometry message type.
struct Mavsdk_Rpc_Telemetry_Odometry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp (0 to use Backend timestamp).
  var timeUsec: UInt64 {
    get {return _storage._timeUsec}
    set {_uniqueStorage()._timeUsec = newValue}
  }

  /// Coordinate frame of reference for the pose data.
  var frameID: Mavsdk_Rpc_Telemetry_Odometry.MavFrame {
    get {return _storage._frameID}
    set {_uniqueStorage()._frameID = newValue}
  }

  /// Coordinate frame of reference for the velocity in free space (twist) data.
  var childFrameID: Mavsdk_Rpc_Telemetry_Odometry.MavFrame {
    get {return _storage._childFrameID}
    set {_uniqueStorage()._childFrameID = newValue}
  }

  /// Position.
  var positionBody: Mavsdk_Rpc_Telemetry_PositionBody {
    get {return _storage._positionBody ?? Mavsdk_Rpc_Telemetry_PositionBody()}
    set {_uniqueStorage()._positionBody = newValue}
  }
  /// Returns true if `positionBody` has been explicitly set.
  var hasPositionBody: Bool {return _storage._positionBody != nil}
  /// Clears the value of `positionBody`. Subsequent reads from it will return its default value.
  mutating func clearPositionBody() {_uniqueStorage()._positionBody = nil}

  /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation).
  var q: Mavsdk_Rpc_Telemetry_Quaternion {
    get {return _storage._q ?? Mavsdk_Rpc_Telemetry_Quaternion()}
    set {_uniqueStorage()._q = newValue}
  }
  /// Returns true if `q` has been explicitly set.
  var hasQ: Bool {return _storage._q != nil}
  /// Clears the value of `q`. Subsequent reads from it will return its default value.
  mutating func clearQ() {_uniqueStorage()._q = nil}

  /// Linear velocity (m/s).
  var velocityBody: Mavsdk_Rpc_Telemetry_VelocityBody {
    get {return _storage._velocityBody ?? Mavsdk_Rpc_Telemetry_VelocityBody()}
    set {_uniqueStorage()._velocityBody = newValue}
  }
  /// Returns true if `velocityBody` has been explicitly set.
  var hasVelocityBody: Bool {return _storage._velocityBody != nil}
  /// Clears the value of `velocityBody`. Subsequent reads from it will return its default value.
  mutating func clearVelocityBody() {_uniqueStorage()._velocityBody = nil}

  /// Angular velocity (rad/s).
  var angularVelocityBody: Mavsdk_Rpc_Telemetry_AngularVelocityBody {
    get {return _storage._angularVelocityBody ?? Mavsdk_Rpc_Telemetry_AngularVelocityBody()}
    set {_uniqueStorage()._angularVelocityBody = newValue}
  }
  /// Returns true if `angularVelocityBody` has been explicitly set.
  var hasAngularVelocityBody: Bool {return _storage._angularVelocityBody != nil}
  /// Clears the value of `angularVelocityBody`. Subsequent reads from it will return its default value.
  mutating func clearAngularVelocityBody() {_uniqueStorage()._angularVelocityBody = nil}

  /// Pose cross-covariance matrix.
  var poseCovariance: Mavsdk_Rpc_Telemetry_Covariance {
    get {return _storage._poseCovariance ?? Mavsdk_Rpc_Telemetry_Covariance()}
    set {_uniqueStorage()._poseCovariance = newValue}
  }
  /// Returns true if `poseCovariance` has been explicitly set.
  var hasPoseCovariance: Bool {return _storage._poseCovariance != nil}
  /// Clears the value of `poseCovariance`. Subsequent reads from it will return its default value.
  mutating func clearPoseCovariance() {_uniqueStorage()._poseCovariance = nil}

  /// Velocity cross-covariance matrix.
  var velocityCovariance: Mavsdk_Rpc_Telemetry_Covariance {
    get {return _storage._velocityCovariance ?? Mavsdk_Rpc_Telemetry_Covariance()}
    set {_uniqueStorage()._velocityCovariance = newValue}
  }
  /// Returns true if `velocityCovariance` has been explicitly set.
  var hasVelocityCovariance: Bool {return _storage._velocityCovariance != nil}
  /// Clears the value of `velocityCovariance`. Subsequent reads from it will return its default value.
  mutating func clearVelocityCovariance() {_uniqueStorage()._velocityCovariance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Mavlink frame id
  enum MavFrame: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Frame is undefined.
    case undef // = 0

    /// Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right.
    case bodyNed // = 8

    /// Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: north, y: east, z: down).
    case visionNed // = 16

    /// Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: north, y: east, z: down).
    case estimNed // = 18
    case UNRECOGNIZED(Int)

    init() {
      self = .undef
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undef
      case 8: self = .bodyNed
      case 16: self = .visionNed
      case 18: self = .estimNed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undef: return 0
      case .bodyNed: return 8
      case .visionNed: return 16
      case .estimNed: return 18
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Mavsdk_Rpc_Telemetry_Odometry.MavFrame: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Telemetry_Odometry.MavFrame] = [
    .undef,
    .bodyNed,
    .visionNed,
    .estimNed,
  ]
}

#endif  // swift(>=4.2)

/// DistanceSensor message type.
struct Mavsdk_Rpc_Telemetry_DistanceSensor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum distance the sensor can measure, NaN if unknown.
  var minimumDistanceM: Float = 0

  /// Maximum distance the sensor can measure, NaN if unknown.
  var maximumDistanceM: Float = 0

  /// Current distance reading, NaN if unknown.
  var currentDistanceM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Scaled Pressure message type.
struct Mavsdk_Rpc_Telemetry_ScaledPressure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp (time since system boot)
  var timestampUs: UInt64 = 0

  /// Absolute pressure in hPa
  var absolutePressureHpa: Float = 0

  /// Differential pressure 1 in hPa
  var differentialPressureHpa: Float = 0

  /// Absolute pressure temperature (in celsius)
  var temperatureDeg: Float = 0

  /// Differential pressure temperature (in celsius, 0 if not available)
  var differentialPressureTemperatureDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PositionNed message type.
struct Mavsdk_Rpc_Telemetry_PositionNed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position along north direction in metres
  var northM: Float = 0

  /// Position along east direction in metres
  var eastM: Float = 0

  /// Position along down direction in metres
  var downM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// VelocityNed message type.
struct Mavsdk_Rpc_Telemetry_VelocityNed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Velocity along north direction in metres per second
  var northMS: Float = 0

  /// Velocity along east direction in metres per second
  var eastMS: Float = 0

  /// Velocity along down direction in metres per second
  var downMS: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PositionVelocityNed message type.
struct Mavsdk_Rpc_Telemetry_PositionVelocityNed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position (NED)
  var position: Mavsdk_Rpc_Telemetry_PositionNed {
    get {return _position ?? Mavsdk_Rpc_Telemetry_PositionNed()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  /// Velocity (NED)
  var velocity: Mavsdk_Rpc_Telemetry_VelocityNed {
    get {return _velocity ?? Mavsdk_Rpc_Telemetry_VelocityNed()}
    set {_velocity = newValue}
  }
  /// Returns true if `velocity` has been explicitly set.
  var hasVelocity: Bool {return self._velocity != nil}
  /// Clears the value of `velocity`. Subsequent reads from it will return its default value.
  mutating func clearVelocity() {self._velocity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Mavsdk_Rpc_Telemetry_PositionNed? = nil
  fileprivate var _velocity: Mavsdk_Rpc_Telemetry_VelocityNed? = nil
}

/// GroundTruth message type.
struct Mavsdk_Rpc_Telemetry_GroundTruth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Latitude in degrees (range: -90 to +90)
  var latitudeDeg: Double = 0

  /// Longitude in degrees (range: -180 to 180)
  var longitudeDeg: Double = 0

  /// Altitude AMSL (above mean sea level) in metres
  var absoluteAltitudeM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// FixedwingMetrics message type.
struct Mavsdk_Rpc_Telemetry_FixedwingMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current indicated airspeed (IAS) in metres per second
  var airspeedMS: Float = 0

  /// Current throttle setting (0 to 100)
  var throttlePercentage: Float = 0

  /// Current climb rate in metres per second
  var climbRateMS: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccelerationFrd message type.
struct Mavsdk_Rpc_Telemetry_AccelerationFrd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Acceleration in forward direction in metres per second^2
  var forwardMS2: Float = 0

  /// Acceleration in right direction in metres per second^2
  var rightMS2: Float = 0

  /// Acceleration in down direction in metres per second^2
  var downMS2: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AngularVelocityFrd message type.
struct Mavsdk_Rpc_Telemetry_AngularVelocityFrd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Angular velocity in forward direction in radians per second
  var forwardRadS: Float = 0

  /// Angular velocity in right direction in radians per second
  var rightRadS: Float = 0

  /// Angular velocity in Down direction in radians per second
  var downRadS: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MagneticFieldFrd message type.
struct Mavsdk_Rpc_Telemetry_MagneticFieldFrd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Magnetic field in forward direction measured in Gauss
  var forwardGauss: Float = 0

  /// Magnetic field in East direction measured in Gauss
  var rightGauss: Float = 0

  /// Magnetic field in Down direction measured in Gauss
  var downGauss: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Imu message type.
struct Mavsdk_Rpc_Telemetry_Imu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Acceleration
  var accelerationFrd: Mavsdk_Rpc_Telemetry_AccelerationFrd {
    get {return _accelerationFrd ?? Mavsdk_Rpc_Telemetry_AccelerationFrd()}
    set {_accelerationFrd = newValue}
  }
  /// Returns true if `accelerationFrd` has been explicitly set.
  var hasAccelerationFrd: Bool {return self._accelerationFrd != nil}
  /// Clears the value of `accelerationFrd`. Subsequent reads from it will return its default value.
  mutating func clearAccelerationFrd() {self._accelerationFrd = nil}

  /// Angular velocity
  var angularVelocityFrd: Mavsdk_Rpc_Telemetry_AngularVelocityFrd {
    get {return _angularVelocityFrd ?? Mavsdk_Rpc_Telemetry_AngularVelocityFrd()}
    set {_angularVelocityFrd = newValue}
  }
  /// Returns true if `angularVelocityFrd` has been explicitly set.
  var hasAngularVelocityFrd: Bool {return self._angularVelocityFrd != nil}
  /// Clears the value of `angularVelocityFrd`. Subsequent reads from it will return its default value.
  mutating func clearAngularVelocityFrd() {self._angularVelocityFrd = nil}

  /// Magnetic field
  var magneticFieldFrd: Mavsdk_Rpc_Telemetry_MagneticFieldFrd {
    get {return _magneticFieldFrd ?? Mavsdk_Rpc_Telemetry_MagneticFieldFrd()}
    set {_magneticFieldFrd = newValue}
  }
  /// Returns true if `magneticFieldFrd` has been explicitly set.
  var hasMagneticFieldFrd: Bool {return self._magneticFieldFrd != nil}
  /// Clears the value of `magneticFieldFrd`. Subsequent reads from it will return its default value.
  mutating func clearMagneticFieldFrd() {self._magneticFieldFrd = nil}

  /// Temperature
  var temperatureDegc: Float = 0

  /// Timestamp in microseconds
  var timestampUs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accelerationFrd: Mavsdk_Rpc_Telemetry_AccelerationFrd? = nil
  fileprivate var _angularVelocityFrd: Mavsdk_Rpc_Telemetry_AngularVelocityFrd? = nil
  fileprivate var _magneticFieldFrd: Mavsdk_Rpc_Telemetry_MagneticFieldFrd? = nil
}

/// Gps global origin type.
struct Mavsdk_Rpc_Telemetry_GpsGlobalOrigin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Latitude of the origin
  var latitudeDeg: Double = 0

  /// Longitude of the origin
  var longitudeDeg: Double = 0

  /// Altitude AMSL (above mean sea level) in metres
  var altitudeM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result type.
struct Mavsdk_Rpc_Telemetry_TelemetryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result enum value
  var result: Mavsdk_Rpc_Telemetry_TelemetryResult.Result = .unknown

  /// Human-readable English string describing the result
  var resultStr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible results returned for telemetry requests.
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result
    case unknown // = 0

    /// Success: the telemetry command was accepted by the vehicle
    case success // = 1

    /// No system connected
    case noSystem // = 2

    /// Connection error
    case connectionError // = 3

    /// Vehicle is busy
    case busy // = 4

    /// Command refused by vehicle
    case commandDenied // = 5

    /// Request timed out
    case timeout // = 6

    /// Request not supported
    case unsupported // = 7
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .noSystem
      case 3: self = .connectionError
      case 4: self = .busy
      case 5: self = .commandDenied
      case 6: self = .timeout
      case 7: self = .unsupported
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .noSystem: return 2
      case .connectionError: return 3
      case .busy: return 4
      case .commandDenied: return 5
      case .timeout: return 6
      case .unsupported: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mavsdk_Rpc_Telemetry_TelemetryResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Telemetry_TelemetryResult.Result] = [
    .unknown,
    .success,
    .noSystem,
    .connectionError,
    .busy,
    .commandDenied,
    .timeout,
    .unsupported,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mavsdk.rpc.telemetry"

extension Mavsdk_Rpc_Telemetry_FixType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIX_TYPE_NO_GPS"),
    1: .same(proto: "FIX_TYPE_NO_FIX"),
    2: .same(proto: "FIX_TYPE_FIX_2D"),
    3: .same(proto: "FIX_TYPE_FIX_3D"),
    4: .same(proto: "FIX_TYPE_FIX_DGPS"),
    5: .same(proto: "FIX_TYPE_RTK_FLOAT"),
    6: .same(proto: "FIX_TYPE_RTK_FIXED"),
  ]
}

extension Mavsdk_Rpc_Telemetry_FlightMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FLIGHT_MODE_UNKNOWN"),
    1: .same(proto: "FLIGHT_MODE_READY"),
    2: .same(proto: "FLIGHT_MODE_TAKEOFF"),
    3: .same(proto: "FLIGHT_MODE_HOLD"),
    4: .same(proto: "FLIGHT_MODE_MISSION"),
    5: .same(proto: "FLIGHT_MODE_RETURN_TO_LAUNCH"),
    6: .same(proto: "FLIGHT_MODE_LAND"),
    7: .same(proto: "FLIGHT_MODE_OFFBOARD"),
    8: .same(proto: "FLIGHT_MODE_FOLLOW_ME"),
    9: .same(proto: "FLIGHT_MODE_MANUAL"),
    10: .same(proto: "FLIGHT_MODE_ALTCTL"),
    11: .same(proto: "FLIGHT_MODE_POSCTL"),
    12: .same(proto: "FLIGHT_MODE_ACRO"),
    13: .same(proto: "FLIGHT_MODE_STABILIZED"),
    14: .same(proto: "FLIGHT_MODE_RATTITUDE"),
  ]
}

extension Mavsdk_Rpc_Telemetry_StatusTextType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_TEXT_TYPE_DEBUG"),
    1: .same(proto: "STATUS_TEXT_TYPE_INFO"),
    2: .same(proto: "STATUS_TEXT_TYPE_NOTICE"),
    3: .same(proto: "STATUS_TEXT_TYPE_WARNING"),
    4: .same(proto: "STATUS_TEXT_TYPE_ERROR"),
    5: .same(proto: "STATUS_TEXT_TYPE_CRITICAL"),
    6: .same(proto: "STATUS_TEXT_TYPE_ALERT"),
    7: .same(proto: "STATUS_TEXT_TYPE_EMERGENCY"),
  ]
}

extension Mavsdk_Rpc_Telemetry_LandedState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LANDED_STATE_UNKNOWN"),
    1: .same(proto: "LANDED_STATE_ON_GROUND"),
    2: .same(proto: "LANDED_STATE_IN_AIR"),
    3: .same(proto: "LANDED_STATE_TAKING_OFF"),
    4: .same(proto: "LANDED_STATE_LANDING"),
  ]
}

extension Mavsdk_Rpc_Telemetry_VtolState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VTOL_STATE_UNDEFINED"),
    1: .same(proto: "VTOL_STATE_TRANSITION_TO_FW"),
    2: .same(proto: "VTOL_STATE_TRANSITION_TO_MC"),
    3: .same(proto: "VTOL_STATE_MC"),
    4: .same(proto: "VTOL_STATE_FW"),
  ]
}

extension Mavsdk_Rpc_Telemetry_SubscribePositionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribePositionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribePositionRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribePositionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_PositionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_PositionResponse, rhs: Mavsdk_Rpc_Telemetry_PositionResponse) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeHomeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeHomeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeHomeRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeHomeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_HomeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HomeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "home"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._home) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._home {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_HomeResponse, rhs: Mavsdk_Rpc_Telemetry_HomeResponse) -> Bool {
    if lhs._home != rhs._home {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeInAirRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeInAirRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeInAirRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeInAirRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_InAirResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InAirResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_in_air"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isInAir) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isInAir != false {
      try visitor.visitSingularBoolField(value: self.isInAir, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_InAirResponse, rhs: Mavsdk_Rpc_Telemetry_InAirResponse) -> Bool {
    if lhs.isInAir != rhs.isInAir {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeLandedStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeLandedStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeLandedStateRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeLandedStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_LandedStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LandedStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "landed_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.landedState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.landedState != .unknown {
      try visitor.visitSingularEnumField(value: self.landedState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_LandedStateResponse, rhs: Mavsdk_Rpc_Telemetry_LandedStateResponse) -> Bool {
    if lhs.landedState != rhs.landedState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeArmedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeArmedRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeArmedRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeArmedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ArmedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArmedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_armed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isArmed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isArmed != false {
      try visitor.visitSingularBoolField(value: self.isArmed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ArmedResponse, rhs: Mavsdk_Rpc_Telemetry_ArmedResponse) -> Bool {
    if lhs.isArmed != rhs.isArmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeVtolStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeVtolStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeVtolStateRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeVtolStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_VtolStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VtolStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vtol_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.vtolState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vtolState != .undefined {
      try visitor.visitSingularEnumField(value: self.vtolState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_VtolStateResponse, rhs: Mavsdk_Rpc_Telemetry_VtolStateResponse) -> Bool {
    if lhs.vtolState != rhs.vtolState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeAttitudeQuaternionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeAttitudeQuaternionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeAttitudeQuaternionRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeAttitudeQuaternionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_AttitudeQuaternionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttitudeQuaternionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attitude_quaternion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attitudeQuaternion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attitudeQuaternion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_AttitudeQuaternionResponse, rhs: Mavsdk_Rpc_Telemetry_AttitudeQuaternionResponse) -> Bool {
    if lhs._attitudeQuaternion != rhs._attitudeQuaternion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeAttitudeEulerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeAttitudeEulerRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeAttitudeEulerRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeAttitudeEulerRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_AttitudeEulerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttitudeEulerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attitude_euler"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attitudeEuler) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attitudeEuler {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_AttitudeEulerResponse, rhs: Mavsdk_Rpc_Telemetry_AttitudeEulerResponse) -> Bool {
    if lhs._attitudeEuler != rhs._attitudeEuler {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeAttitudeAngularVelocityBodyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeAttitudeAngularVelocityBodyRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeAttitudeAngularVelocityBodyRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeAttitudeAngularVelocityBodyRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_AttitudeAngularVelocityBodyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttitudeAngularVelocityBodyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attitude_angular_velocity_body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attitudeAngularVelocityBody) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attitudeAngularVelocityBody {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_AttitudeAngularVelocityBodyResponse, rhs: Mavsdk_Rpc_Telemetry_AttitudeAngularVelocityBodyResponse) -> Bool {
    if lhs._attitudeAngularVelocityBody != rhs._attitudeAngularVelocityBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeCameraAttitudeQuaternionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeCameraAttitudeQuaternionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeCameraAttitudeQuaternionRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeCameraAttitudeQuaternionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_CameraAttitudeQuaternionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CameraAttitudeQuaternionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attitude_quaternion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attitudeQuaternion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attitudeQuaternion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_CameraAttitudeQuaternionResponse, rhs: Mavsdk_Rpc_Telemetry_CameraAttitudeQuaternionResponse) -> Bool {
    if lhs._attitudeQuaternion != rhs._attitudeQuaternion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeCameraAttitudeEulerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeCameraAttitudeEulerRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeCameraAttitudeEulerRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeCameraAttitudeEulerRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_CameraAttitudeEulerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CameraAttitudeEulerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attitude_euler"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attitudeEuler) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attitudeEuler {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_CameraAttitudeEulerResponse, rhs: Mavsdk_Rpc_Telemetry_CameraAttitudeEulerResponse) -> Bool {
    if lhs._attitudeEuler != rhs._attitudeEuler {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeVelocityNedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeVelocityNedRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeVelocityNedRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeVelocityNedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_VelocityNedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VelocityNedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "velocity_ned"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._velocityNed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._velocityNed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_VelocityNedResponse, rhs: Mavsdk_Rpc_Telemetry_VelocityNedResponse) -> Bool {
    if lhs._velocityNed != rhs._velocityNed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeGpsInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeGpsInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeGpsInfoRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeGpsInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_GpsInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GpsInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gps_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._gpsInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gpsInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_GpsInfoResponse, rhs: Mavsdk_Rpc_Telemetry_GpsInfoResponse) -> Bool {
    if lhs._gpsInfo != rhs._gpsInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeRawGpsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeRawGpsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeRawGpsRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeRawGpsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_RawGpsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawGpsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_gps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawGps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawGps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_RawGpsResponse, rhs: Mavsdk_Rpc_Telemetry_RawGpsResponse) -> Bool {
    if lhs._rawGps != rhs._rawGps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeBatteryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeBatteryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeBatteryRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeBatteryRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_BatteryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "battery"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._battery) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._battery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_BatteryResponse, rhs: Mavsdk_Rpc_Telemetry_BatteryResponse) -> Bool {
    if lhs._battery != rhs._battery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeFlightModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeFlightModeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeFlightModeRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeFlightModeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_FlightModeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlightModeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "flight_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.flightMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.flightMode != .unknown {
      try visitor.visitSingularEnumField(value: self.flightMode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_FlightModeResponse, rhs: Mavsdk_Rpc_Telemetry_FlightModeResponse) -> Bool {
    if lhs.flightMode != rhs.flightMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeHealthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeHealthRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeHealthRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeHealthRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_HealthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "health"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._health) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._health {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_HealthResponse, rhs: Mavsdk_Rpc_Telemetry_HealthResponse) -> Bool {
    if lhs._health != rhs._health {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeRcStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeRcStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeRcStatusRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeRcStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_RcStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RcStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rc_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rcStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rcStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_RcStatusResponse, rhs: Mavsdk_Rpc_Telemetry_RcStatusResponse) -> Bool {
    if lhs._rcStatus != rhs._rcStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeStatusTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeStatusTextRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeStatusTextRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeStatusTextRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_StatusTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusTextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._statusText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._statusText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_StatusTextResponse, rhs: Mavsdk_Rpc_Telemetry_StatusTextResponse) -> Bool {
    if lhs._statusText != rhs._statusText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeActuatorControlTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeActuatorControlTargetRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeActuatorControlTargetRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeActuatorControlTargetRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ActuatorControlTargetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActuatorControlTargetResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actuator_control_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actuatorControlTarget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actuatorControlTarget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ActuatorControlTargetResponse, rhs: Mavsdk_Rpc_Telemetry_ActuatorControlTargetResponse) -> Bool {
    if lhs._actuatorControlTarget != rhs._actuatorControlTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeActuatorOutputStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeActuatorOutputStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeActuatorOutputStatusRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeActuatorOutputStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ActuatorOutputStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActuatorOutputStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actuator_output_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actuatorOutputStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actuatorOutputStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ActuatorOutputStatusResponse, rhs: Mavsdk_Rpc_Telemetry_ActuatorOutputStatusResponse) -> Bool {
    if lhs._actuatorOutputStatus != rhs._actuatorOutputStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeOdometryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeOdometryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeOdometryRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeOdometryRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_OdometryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OdometryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "odometry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._odometry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._odometry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_OdometryResponse, rhs: Mavsdk_Rpc_Telemetry_OdometryResponse) -> Bool {
    if lhs._odometry != rhs._odometry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribePositionVelocityNedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribePositionVelocityNedRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribePositionVelocityNedRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribePositionVelocityNedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_PositionVelocityNedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionVelocityNedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_velocity_ned"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positionVelocityNed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._positionVelocityNed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_PositionVelocityNedResponse, rhs: Mavsdk_Rpc_Telemetry_PositionVelocityNedResponse) -> Bool {
    if lhs._positionVelocityNed != rhs._positionVelocityNed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeGroundTruthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeGroundTruthRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeGroundTruthRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeGroundTruthRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_GroundTruthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroundTruthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ground_truth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groundTruth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groundTruth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_GroundTruthResponse, rhs: Mavsdk_Rpc_Telemetry_GroundTruthResponse) -> Bool {
    if lhs._groundTruth != rhs._groundTruth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeFixedwingMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeFixedwingMetricsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeFixedwingMetricsRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeFixedwingMetricsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_FixedwingMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FixedwingMetricsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fixedwing_metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fixedwingMetrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fixedwingMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_FixedwingMetricsResponse, rhs: Mavsdk_Rpc_Telemetry_FixedwingMetricsResponse) -> Bool {
    if lhs._fixedwingMetrics != rhs._fixedwingMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeImuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeImuRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeImuRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeImuRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ImuResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "imu"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._imu) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ImuResponse, rhs: Mavsdk_Rpc_Telemetry_ImuResponse) -> Bool {
    if lhs._imu != rhs._imu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeScaledImuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeScaledImuRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeScaledImuRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeScaledImuRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ScaledImuResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaledImuResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "imu"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._imu) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ScaledImuResponse, rhs: Mavsdk_Rpc_Telemetry_ScaledImuResponse) -> Bool {
    if lhs._imu != rhs._imu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeRawImuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeRawImuRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeRawImuRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeRawImuRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_RawImuResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawImuResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "imu"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._imu) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_RawImuResponse, rhs: Mavsdk_Rpc_Telemetry_RawImuResponse) -> Bool {
    if lhs._imu != rhs._imu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeHealthAllOkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeHealthAllOkRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeHealthAllOkRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeHealthAllOkRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_HealthAllOkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthAllOkResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_health_all_ok"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isHealthAllOk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isHealthAllOk != false {
      try visitor.visitSingularBoolField(value: self.isHealthAllOk, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_HealthAllOkResponse, rhs: Mavsdk_Rpc_Telemetry_HealthAllOkResponse) -> Bool {
    if lhs.isHealthAllOk != rhs.isHealthAllOk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeUnixEpochTimeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeUnixEpochTimeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeUnixEpochTimeRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeUnixEpochTimeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_UnixEpochTimeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnixEpochTimeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_us"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timeUs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeUs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_UnixEpochTimeResponse, rhs: Mavsdk_Rpc_Telemetry_UnixEpochTimeResponse) -> Bool {
    if lhs.timeUs != rhs.timeUs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeDistanceSensorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeDistanceSensorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeDistanceSensorRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeDistanceSensorRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_DistanceSensorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistanceSensorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distance_sensor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._distanceSensor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._distanceSensor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_DistanceSensorResponse, rhs: Mavsdk_Rpc_Telemetry_DistanceSensorResponse) -> Bool {
    if lhs._distanceSensor != rhs._distanceSensor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeScaledPressureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeScaledPressureRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeScaledPressureRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeScaledPressureRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ScaledPressureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaledPressureResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scaled_pressure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scaledPressure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scaledPressure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ScaledPressureResponse, rhs: Mavsdk_Rpc_Telemetry_ScaledPressureResponse) -> Bool {
    if lhs._scaledPressure != rhs._scaledPressure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SubscribeHeadingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeHeadingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SubscribeHeadingRequest, rhs: Mavsdk_Rpc_Telemetry_SubscribeHeadingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_HeadingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "heading_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._headingDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._headingDeg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_HeadingResponse, rhs: Mavsdk_Rpc_Telemetry_HeadingResponse) -> Bool {
    if lhs._headingDeg != rhs._headingDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRatePositionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRatePositionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRatePositionRequest, rhs: Mavsdk_Rpc_Telemetry_SetRatePositionRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRatePositionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRatePositionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRatePositionResponse, rhs: Mavsdk_Rpc_Telemetry_SetRatePositionResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateHomeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateHomeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateHomeRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateHomeRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateHomeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateHomeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateHomeResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateHomeResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateInAirRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateInAirRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateInAirRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateInAirRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateInAirResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateInAirResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateInAirResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateInAirResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateLandedStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateLandedStateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateLandedStateRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateLandedStateRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateLandedStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateLandedStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateLandedStateResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateLandedStateResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateVtolStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateVtolStateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateVtolStateRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateVtolStateRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateVtolStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateVtolStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateVtolStateResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateVtolStateResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateAttitudeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateAttitudeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateAttitudeRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateAttitudeRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateAttitudeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateAttitudeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateAttitudeResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateAttitudeResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateAttitudeAngularVelocityBodyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateAttitudeAngularVelocityBodyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateAttitudeAngularVelocityBodyRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateAttitudeAngularVelocityBodyRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateAttitudeAngularVelocityBodyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateAttitudeAngularVelocityBodyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateAttitudeAngularVelocityBodyResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateAttitudeAngularVelocityBodyResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeQuaternionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateCameraAttitudeQuaternionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeQuaternionRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeQuaternionRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeQuaternionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateCameraAttitudeQuaternionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeQuaternionResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeQuaternionResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateCameraAttitudeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateCameraAttitudeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateCameraAttitudeResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateVelocityNedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateVelocityNedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateVelocityNedRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateVelocityNedRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateVelocityNedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateVelocityNedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateVelocityNedResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateVelocityNedResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateGpsInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateGpsInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateGpsInfoRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateGpsInfoRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateGpsInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateGpsInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateGpsInfoResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateGpsInfoResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateRawGpsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateRawGpsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateRawGpsRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateRawGpsRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateBatteryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateBatteryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateBatteryRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateBatteryRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateBatteryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateBatteryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateBatteryResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateBatteryResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateRcStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateRcStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateRcStatusRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateRcStatusRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateRcStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateRcStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateRcStatusResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateRcStatusResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateActuatorControlTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateActuatorControlTargetRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateActuatorControlTargetRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateActuatorControlTargetRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateActuatorControlTargetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateActuatorControlTargetResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateActuatorControlTargetResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateActuatorControlTargetResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateActuatorOutputStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateActuatorOutputStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateActuatorOutputStatusRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateActuatorOutputStatusRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateActuatorOutputStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateActuatorOutputStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateActuatorOutputStatusResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateActuatorOutputStatusResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateOdometryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateOdometryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateOdometryRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateOdometryRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateOdometryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateOdometryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateOdometryResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateOdometryResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRatePositionVelocityNedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRatePositionVelocityNedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRatePositionVelocityNedRequest, rhs: Mavsdk_Rpc_Telemetry_SetRatePositionVelocityNedRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRatePositionVelocityNedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRatePositionVelocityNedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRatePositionVelocityNedResponse, rhs: Mavsdk_Rpc_Telemetry_SetRatePositionVelocityNedResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateGroundTruthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateGroundTruthRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateGroundTruthRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateGroundTruthRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateGroundTruthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateGroundTruthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateGroundTruthResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateGroundTruthResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateFixedwingMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateFixedwingMetricsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateFixedwingMetricsRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateFixedwingMetricsRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateFixedwingMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateFixedwingMetricsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateFixedwingMetricsResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateFixedwingMetricsResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateImuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateImuRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateImuRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateImuRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateImuResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateImuResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateImuResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateImuResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateScaledImuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateScaledImuRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateScaledImuRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateScaledImuRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateScaledImuResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateScaledImuResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateScaledImuResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateScaledImuResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateRawImuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateRawImuRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateRawImuRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateRawImuRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateRawImuResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateRawImuResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateRawImuResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateRawImuResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateUnixEpochTimeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateUnixEpochTimeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateUnixEpochTimeRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateUnixEpochTimeRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateUnixEpochTimeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateUnixEpochTimeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateUnixEpochTimeResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateUnixEpochTimeResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateDistanceSensorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateDistanceSensorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rate_hz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.rateHz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rateHz != 0 {
      try visitor.visitSingularDoubleField(value: self.rateHz, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateDistanceSensorRequest, rhs: Mavsdk_Rpc_Telemetry_SetRateDistanceSensorRequest) -> Bool {
    if lhs.rateHz != rhs.rateHz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_SetRateDistanceSensorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateDistanceSensorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_SetRateDistanceSensorResponse, rhs: Mavsdk_Rpc_Telemetry_SetRateDistanceSensorResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_GetGpsGlobalOriginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGpsGlobalOriginRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_GetGpsGlobalOriginRequest, rhs: Mavsdk_Rpc_Telemetry_GetGpsGlobalOriginRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_GetGpsGlobalOriginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGpsGlobalOriginResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telemetry_result"),
    2: .standard(proto: "gps_global_origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._telemetryResult) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gpsGlobalOrigin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._telemetryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gpsGlobalOrigin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_GetGpsGlobalOriginResponse, rhs: Mavsdk_Rpc_Telemetry_GetGpsGlobalOriginResponse) -> Bool {
    if lhs._telemetryResult != rhs._telemetryResult {return false}
    if lhs._gpsGlobalOrigin != rhs._gpsGlobalOrigin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latitude_deg"),
    2: .standard(proto: "longitude_deg"),
    3: .standard(proto: "absolute_altitude_m"),
    4: .standard(proto: "relative_altitude_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitudeDeg) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitudeDeg) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.absoluteAltitudeM) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.relativeAltitudeM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.latitudeDeg, fieldNumber: 1)
    }
    if self.longitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.longitudeDeg, fieldNumber: 2)
    }
    if self.absoluteAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.absoluteAltitudeM, fieldNumber: 3)
    }
    if self.relativeAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.relativeAltitudeM, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_Position, rhs: Mavsdk_Rpc_Telemetry_Position) -> Bool {
    if lhs.latitudeDeg != rhs.latitudeDeg {return false}
    if lhs.longitudeDeg != rhs.longitudeDeg {return false}
    if lhs.absoluteAltitudeM != rhs.absoluteAltitudeM {return false}
    if lhs.relativeAltitudeM != rhs.relativeAltitudeM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Heading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Heading"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "heading_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.headingDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.headingDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.headingDeg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_Heading, rhs: Mavsdk_Rpc_Telemetry_Heading) -> Bool {
    if lhs.headingDeg != rhs.headingDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Quaternion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Quaternion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "w"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "z"),
    5: .standard(proto: "timestamp_us"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.w) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.timestampUs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.w != 0 {
      try visitor.visitSingularFloatField(value: self.w, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 3)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 4)
    }
    if self.timestampUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampUs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_Quaternion, rhs: Mavsdk_Rpc_Telemetry_Quaternion) -> Bool {
    if lhs.w != rhs.w {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.timestampUs != rhs.timestampUs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_EulerAngle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EulerAngle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "roll_deg"),
    2: .standard(proto: "pitch_deg"),
    3: .standard(proto: "yaw_deg"),
    4: .standard(proto: "timestamp_us"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.rollDeg) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.pitchDeg) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.yawDeg) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timestampUs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rollDeg != 0 {
      try visitor.visitSingularFloatField(value: self.rollDeg, fieldNumber: 1)
    }
    if self.pitchDeg != 0 {
      try visitor.visitSingularFloatField(value: self.pitchDeg, fieldNumber: 2)
    }
    if self.yawDeg != 0 {
      try visitor.visitSingularFloatField(value: self.yawDeg, fieldNumber: 3)
    }
    if self.timestampUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampUs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_EulerAngle, rhs: Mavsdk_Rpc_Telemetry_EulerAngle) -> Bool {
    if lhs.rollDeg != rhs.rollDeg {return false}
    if lhs.pitchDeg != rhs.pitchDeg {return false}
    if lhs.yawDeg != rhs.yawDeg {return false}
    if lhs.timestampUs != rhs.timestampUs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_AngularVelocityBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AngularVelocityBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "roll_rad_s"),
    2: .standard(proto: "pitch_rad_s"),
    3: .standard(proto: "yaw_rad_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.rollRadS) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.pitchRadS) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.yawRadS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rollRadS != 0 {
      try visitor.visitSingularFloatField(value: self.rollRadS, fieldNumber: 1)
    }
    if self.pitchRadS != 0 {
      try visitor.visitSingularFloatField(value: self.pitchRadS, fieldNumber: 2)
    }
    if self.yawRadS != 0 {
      try visitor.visitSingularFloatField(value: self.yawRadS, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_AngularVelocityBody, rhs: Mavsdk_Rpc_Telemetry_AngularVelocityBody) -> Bool {
    if lhs.rollRadS != rhs.rollRadS {return false}
    if lhs.pitchRadS != rhs.pitchRadS {return false}
    if lhs.yawRadS != rhs.yawRadS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_GpsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GpsInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_satellites"),
    2: .standard(proto: "fix_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numSatellites) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.fixType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numSatellites != 0 {
      try visitor.visitSingularInt32Field(value: self.numSatellites, fieldNumber: 1)
    }
    if self.fixType != .noGps {
      try visitor.visitSingularEnumField(value: self.fixType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_GpsInfo, rhs: Mavsdk_Rpc_Telemetry_GpsInfo) -> Bool {
    if lhs.numSatellites != rhs.numSatellites {return false}
    if lhs.fixType != rhs.fixType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_RawGps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawGps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_us"),
    2: .standard(proto: "latitude_deg"),
    3: .standard(proto: "longitude_deg"),
    4: .standard(proto: "absolute_altitude_m"),
    5: .same(proto: "hdop"),
    6: .same(proto: "vdop"),
    7: .standard(proto: "velocity_m_s"),
    8: .standard(proto: "cog_deg"),
    9: .standard(proto: "altitude_ellipsoid_m"),
    10: .standard(proto: "horizontal_uncertainty_m"),
    11: .standard(proto: "vertical_uncertainty_m"),
    12: .standard(proto: "velocity_uncertainty_m_s"),
    13: .standard(proto: "heading_uncertainty_deg"),
    14: .standard(proto: "yaw_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timestampUs) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.latitudeDeg) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.longitudeDeg) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.absoluteAltitudeM) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.hdop) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.vdop) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.velocityMS) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.cogDeg) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.altitudeEllipsoidM) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.horizontalUncertaintyM) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.verticalUncertaintyM) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.velocityUncertaintyMS) }()
      case 13: try { try decoder.decodeSingularFloatField(value: &self.headingUncertaintyDeg) }()
      case 14: try { try decoder.decodeSingularFloatField(value: &self.yawDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampUs, fieldNumber: 1)
    }
    if self.latitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.latitudeDeg, fieldNumber: 2)
    }
    if self.longitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.longitudeDeg, fieldNumber: 3)
    }
    if self.absoluteAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.absoluteAltitudeM, fieldNumber: 4)
    }
    if self.hdop != 0 {
      try visitor.visitSingularFloatField(value: self.hdop, fieldNumber: 5)
    }
    if self.vdop != 0 {
      try visitor.visitSingularFloatField(value: self.vdop, fieldNumber: 6)
    }
    if self.velocityMS != 0 {
      try visitor.visitSingularFloatField(value: self.velocityMS, fieldNumber: 7)
    }
    if self.cogDeg != 0 {
      try visitor.visitSingularFloatField(value: self.cogDeg, fieldNumber: 8)
    }
    if self.altitudeEllipsoidM != 0 {
      try visitor.visitSingularFloatField(value: self.altitudeEllipsoidM, fieldNumber: 9)
    }
    if self.horizontalUncertaintyM != 0 {
      try visitor.visitSingularFloatField(value: self.horizontalUncertaintyM, fieldNumber: 10)
    }
    if self.verticalUncertaintyM != 0 {
      try visitor.visitSingularFloatField(value: self.verticalUncertaintyM, fieldNumber: 11)
    }
    if self.velocityUncertaintyMS != 0 {
      try visitor.visitSingularFloatField(value: self.velocityUncertaintyMS, fieldNumber: 12)
    }
    if self.headingUncertaintyDeg != 0 {
      try visitor.visitSingularFloatField(value: self.headingUncertaintyDeg, fieldNumber: 13)
    }
    if self.yawDeg != 0 {
      try visitor.visitSingularFloatField(value: self.yawDeg, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_RawGps, rhs: Mavsdk_Rpc_Telemetry_RawGps) -> Bool {
    if lhs.timestampUs != rhs.timestampUs {return false}
    if lhs.latitudeDeg != rhs.latitudeDeg {return false}
    if lhs.longitudeDeg != rhs.longitudeDeg {return false}
    if lhs.absoluteAltitudeM != rhs.absoluteAltitudeM {return false}
    if lhs.hdop != rhs.hdop {return false}
    if lhs.vdop != rhs.vdop {return false}
    if lhs.velocityMS != rhs.velocityMS {return false}
    if lhs.cogDeg != rhs.cogDeg {return false}
    if lhs.altitudeEllipsoidM != rhs.altitudeEllipsoidM {return false}
    if lhs.horizontalUncertaintyM != rhs.horizontalUncertaintyM {return false}
    if lhs.verticalUncertaintyM != rhs.verticalUncertaintyM {return false}
    if lhs.velocityUncertaintyMS != rhs.velocityUncertaintyMS {return false}
    if lhs.headingUncertaintyDeg != rhs.headingUncertaintyDeg {return false}
    if lhs.yawDeg != rhs.yawDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Battery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Battery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "id"),
    1: .standard(proto: "voltage_v"),
    2: .standard(proto: "remaining_percent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.voltageV) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.remainingPercent) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.voltageV != 0 {
      try visitor.visitSingularFloatField(value: self.voltageV, fieldNumber: 1)
    }
    if self.remainingPercent != 0 {
      try visitor.visitSingularFloatField(value: self.remainingPercent, fieldNumber: 2)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_Battery, rhs: Mavsdk_Rpc_Telemetry_Battery) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.voltageV != rhs.voltageV {return false}
    if lhs.remainingPercent != rhs.remainingPercent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Health: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Health"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_gyrometer_calibration_ok"),
    2: .standard(proto: "is_accelerometer_calibration_ok"),
    3: .standard(proto: "is_magnetometer_calibration_ok"),
    5: .standard(proto: "is_local_position_ok"),
    6: .standard(proto: "is_global_position_ok"),
    7: .standard(proto: "is_home_position_ok"),
    8: .standard(proto: "is_armable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isGyrometerCalibrationOk) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isAccelerometerCalibrationOk) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isMagnetometerCalibrationOk) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isLocalPositionOk) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isGlobalPositionOk) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isHomePositionOk) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isArmable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isGyrometerCalibrationOk != false {
      try visitor.visitSingularBoolField(value: self.isGyrometerCalibrationOk, fieldNumber: 1)
    }
    if self.isAccelerometerCalibrationOk != false {
      try visitor.visitSingularBoolField(value: self.isAccelerometerCalibrationOk, fieldNumber: 2)
    }
    if self.isMagnetometerCalibrationOk != false {
      try visitor.visitSingularBoolField(value: self.isMagnetometerCalibrationOk, fieldNumber: 3)
    }
    if self.isLocalPositionOk != false {
      try visitor.visitSingularBoolField(value: self.isLocalPositionOk, fieldNumber: 5)
    }
    if self.isGlobalPositionOk != false {
      try visitor.visitSingularBoolField(value: self.isGlobalPositionOk, fieldNumber: 6)
    }
    if self.isHomePositionOk != false {
      try visitor.visitSingularBoolField(value: self.isHomePositionOk, fieldNumber: 7)
    }
    if self.isArmable != false {
      try visitor.visitSingularBoolField(value: self.isArmable, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_Health, rhs: Mavsdk_Rpc_Telemetry_Health) -> Bool {
    if lhs.isGyrometerCalibrationOk != rhs.isGyrometerCalibrationOk {return false}
    if lhs.isAccelerometerCalibrationOk != rhs.isAccelerometerCalibrationOk {return false}
    if lhs.isMagnetometerCalibrationOk != rhs.isMagnetometerCalibrationOk {return false}
    if lhs.isLocalPositionOk != rhs.isLocalPositionOk {return false}
    if lhs.isGlobalPositionOk != rhs.isGlobalPositionOk {return false}
    if lhs.isHomePositionOk != rhs.isHomePositionOk {return false}
    if lhs.isArmable != rhs.isArmable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_RcStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RcStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "was_available_once"),
    2: .standard(proto: "is_available"),
    3: .standard(proto: "signal_strength_percent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.wasAvailableOnce) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isAvailable) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.signalStrengthPercent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.wasAvailableOnce != false {
      try visitor.visitSingularBoolField(value: self.wasAvailableOnce, fieldNumber: 1)
    }
    if self.isAvailable != false {
      try visitor.visitSingularBoolField(value: self.isAvailable, fieldNumber: 2)
    }
    if self.signalStrengthPercent != 0 {
      try visitor.visitSingularFloatField(value: self.signalStrengthPercent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_RcStatus, rhs: Mavsdk_Rpc_Telemetry_RcStatus) -> Bool {
    if lhs.wasAvailableOnce != rhs.wasAvailableOnce {return false}
    if lhs.isAvailable != rhs.isAvailable {return false}
    if lhs.signalStrengthPercent != rhs.signalStrengthPercent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_StatusText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .debug {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_StatusText, rhs: Mavsdk_Rpc_Telemetry_StatusText) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ActuatorControlTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActuatorControlTarget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "controls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.group) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.controls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt32Field(value: self.group, fieldNumber: 1)
    }
    if !self.controls.isEmpty {
      try visitor.visitPackedFloatField(value: self.controls, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ActuatorControlTarget, rhs: Mavsdk_Rpc_Telemetry_ActuatorControlTarget) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.controls != rhs.controls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ActuatorOutputStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActuatorOutputStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .same(proto: "actuator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.active) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.actuator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.active != 0 {
      try visitor.visitSingularUInt32Field(value: self.active, fieldNumber: 1)
    }
    if !self.actuator.isEmpty {
      try visitor.visitPackedFloatField(value: self.actuator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ActuatorOutputStatus, rhs: Mavsdk_Rpc_Telemetry_ActuatorOutputStatus) -> Bool {
    if lhs.active != rhs.active {return false}
    if lhs.actuator != rhs.actuator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Covariance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Covariance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "covariance_matrix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.covarianceMatrix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.covarianceMatrix.isEmpty {
      try visitor.visitPackedFloatField(value: self.covarianceMatrix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_Covariance, rhs: Mavsdk_Rpc_Telemetry_Covariance) -> Bool {
    if lhs.covarianceMatrix != rhs.covarianceMatrix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_VelocityBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VelocityBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "x_m_s"),
    2: .standard(proto: "y_m_s"),
    3: .standard(proto: "z_m_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.xMS) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.yMS) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.zMS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.xMS != 0 {
      try visitor.visitSingularFloatField(value: self.xMS, fieldNumber: 1)
    }
    if self.yMS != 0 {
      try visitor.visitSingularFloatField(value: self.yMS, fieldNumber: 2)
    }
    if self.zMS != 0 {
      try visitor.visitSingularFloatField(value: self.zMS, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_VelocityBody, rhs: Mavsdk_Rpc_Telemetry_VelocityBody) -> Bool {
    if lhs.xMS != rhs.xMS {return false}
    if lhs.yMS != rhs.yMS {return false}
    if lhs.zMS != rhs.zMS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_PositionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "x_m"),
    2: .standard(proto: "y_m"),
    3: .standard(proto: "z_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.xM) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.yM) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.zM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.xM != 0 {
      try visitor.visitSingularFloatField(value: self.xM, fieldNumber: 1)
    }
    if self.yM != 0 {
      try visitor.visitSingularFloatField(value: self.yM, fieldNumber: 2)
    }
    if self.zM != 0 {
      try visitor.visitSingularFloatField(value: self.zM, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_PositionBody, rhs: Mavsdk_Rpc_Telemetry_PositionBody) -> Bool {
    if lhs.xM != rhs.xM {return false}
    if lhs.yM != rhs.yM {return false}
    if lhs.zM != rhs.zM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Odometry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Odometry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_usec"),
    2: .standard(proto: "frame_id"),
    3: .standard(proto: "child_frame_id"),
    4: .standard(proto: "position_body"),
    5: .same(proto: "q"),
    6: .standard(proto: "velocity_body"),
    7: .standard(proto: "angular_velocity_body"),
    8: .standard(proto: "pose_covariance"),
    9: .standard(proto: "velocity_covariance"),
  ]

  fileprivate class _StorageClass {
    var _timeUsec: UInt64 = 0
    var _frameID: Mavsdk_Rpc_Telemetry_Odometry.MavFrame = .undef
    var _childFrameID: Mavsdk_Rpc_Telemetry_Odometry.MavFrame = .undef
    var _positionBody: Mavsdk_Rpc_Telemetry_PositionBody? = nil
    var _q: Mavsdk_Rpc_Telemetry_Quaternion? = nil
    var _velocityBody: Mavsdk_Rpc_Telemetry_VelocityBody? = nil
    var _angularVelocityBody: Mavsdk_Rpc_Telemetry_AngularVelocityBody? = nil
    var _poseCovariance: Mavsdk_Rpc_Telemetry_Covariance? = nil
    var _velocityCovariance: Mavsdk_Rpc_Telemetry_Covariance? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timeUsec = source._timeUsec
      _frameID = source._frameID
      _childFrameID = source._childFrameID
      _positionBody = source._positionBody
      _q = source._q
      _velocityBody = source._velocityBody
      _angularVelocityBody = source._angularVelocityBody
      _poseCovariance = source._poseCovariance
      _velocityCovariance = source._velocityCovariance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeUsec) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._frameID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._childFrameID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._positionBody) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._q) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._velocityBody) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._angularVelocityBody) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._poseCovariance) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._velocityCovariance) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._timeUsec != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timeUsec, fieldNumber: 1)
      }
      if _storage._frameID != .undef {
        try visitor.visitSingularEnumField(value: _storage._frameID, fieldNumber: 2)
      }
      if _storage._childFrameID != .undef {
        try visitor.visitSingularEnumField(value: _storage._childFrameID, fieldNumber: 3)
      }
      try { if let v = _storage._positionBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._q {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._velocityBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._angularVelocityBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._poseCovariance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._velocityCovariance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_Odometry, rhs: Mavsdk_Rpc_Telemetry_Odometry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timeUsec != rhs_storage._timeUsec {return false}
        if _storage._frameID != rhs_storage._frameID {return false}
        if _storage._childFrameID != rhs_storage._childFrameID {return false}
        if _storage._positionBody != rhs_storage._positionBody {return false}
        if _storage._q != rhs_storage._q {return false}
        if _storage._velocityBody != rhs_storage._velocityBody {return false}
        if _storage._angularVelocityBody != rhs_storage._angularVelocityBody {return false}
        if _storage._poseCovariance != rhs_storage._poseCovariance {return false}
        if _storage._velocityCovariance != rhs_storage._velocityCovariance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Odometry.MavFrame: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAV_FRAME_UNDEF"),
    8: .same(proto: "MAV_FRAME_BODY_NED"),
    16: .same(proto: "MAV_FRAME_VISION_NED"),
    18: .same(proto: "MAV_FRAME_ESTIM_NED"),
  ]
}

extension Mavsdk_Rpc_Telemetry_DistanceSensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistanceSensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_distance_m"),
    2: .standard(proto: "maximum_distance_m"),
    3: .standard(proto: "current_distance_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.minimumDistanceM) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maximumDistanceM) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.currentDistanceM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minimumDistanceM != 0 {
      try visitor.visitSingularFloatField(value: self.minimumDistanceM, fieldNumber: 1)
    }
    if self.maximumDistanceM != 0 {
      try visitor.visitSingularFloatField(value: self.maximumDistanceM, fieldNumber: 2)
    }
    if self.currentDistanceM != 0 {
      try visitor.visitSingularFloatField(value: self.currentDistanceM, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_DistanceSensor, rhs: Mavsdk_Rpc_Telemetry_DistanceSensor) -> Bool {
    if lhs.minimumDistanceM != rhs.minimumDistanceM {return false}
    if lhs.maximumDistanceM != rhs.maximumDistanceM {return false}
    if lhs.currentDistanceM != rhs.currentDistanceM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_ScaledPressure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaledPressure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_us"),
    2: .standard(proto: "absolute_pressure_hpa"),
    3: .standard(proto: "differential_pressure_hpa"),
    4: .standard(proto: "temperature_deg"),
    5: .standard(proto: "differential_pressure_temperature_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timestampUs) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.absolutePressureHpa) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.differentialPressureHpa) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.temperatureDeg) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.differentialPressureTemperatureDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampUs, fieldNumber: 1)
    }
    if self.absolutePressureHpa != 0 {
      try visitor.visitSingularFloatField(value: self.absolutePressureHpa, fieldNumber: 2)
    }
    if self.differentialPressureHpa != 0 {
      try visitor.visitSingularFloatField(value: self.differentialPressureHpa, fieldNumber: 3)
    }
    if self.temperatureDeg != 0 {
      try visitor.visitSingularFloatField(value: self.temperatureDeg, fieldNumber: 4)
    }
    if self.differentialPressureTemperatureDeg != 0 {
      try visitor.visitSingularFloatField(value: self.differentialPressureTemperatureDeg, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_ScaledPressure, rhs: Mavsdk_Rpc_Telemetry_ScaledPressure) -> Bool {
    if lhs.timestampUs != rhs.timestampUs {return false}
    if lhs.absolutePressureHpa != rhs.absolutePressureHpa {return false}
    if lhs.differentialPressureHpa != rhs.differentialPressureHpa {return false}
    if lhs.temperatureDeg != rhs.temperatureDeg {return false}
    if lhs.differentialPressureTemperatureDeg != rhs.differentialPressureTemperatureDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_PositionNed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionNed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "north_m"),
    2: .standard(proto: "east_m"),
    3: .standard(proto: "down_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.northM) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.eastM) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.northM != 0 {
      try visitor.visitSingularFloatField(value: self.northM, fieldNumber: 1)
    }
    if self.eastM != 0 {
      try visitor.visitSingularFloatField(value: self.eastM, fieldNumber: 2)
    }
    if self.downM != 0 {
      try visitor.visitSingularFloatField(value: self.downM, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_PositionNed, rhs: Mavsdk_Rpc_Telemetry_PositionNed) -> Bool {
    if lhs.northM != rhs.northM {return false}
    if lhs.eastM != rhs.eastM {return false}
    if lhs.downM != rhs.downM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_VelocityNed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VelocityNed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "north_m_s"),
    2: .standard(proto: "east_m_s"),
    3: .standard(proto: "down_m_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.northMS) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.eastMS) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downMS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.northMS != 0 {
      try visitor.visitSingularFloatField(value: self.northMS, fieldNumber: 1)
    }
    if self.eastMS != 0 {
      try visitor.visitSingularFloatField(value: self.eastMS, fieldNumber: 2)
    }
    if self.downMS != 0 {
      try visitor.visitSingularFloatField(value: self.downMS, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_VelocityNed, rhs: Mavsdk_Rpc_Telemetry_VelocityNed) -> Bool {
    if lhs.northMS != rhs.northMS {return false}
    if lhs.eastMS != rhs.eastMS {return false}
    if lhs.downMS != rhs.downMS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_PositionVelocityNed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionVelocityNed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "velocity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._velocity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._velocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_PositionVelocityNed, rhs: Mavsdk_Rpc_Telemetry_PositionVelocityNed) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._velocity != rhs._velocity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_GroundTruth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroundTruth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latitude_deg"),
    2: .standard(proto: "longitude_deg"),
    3: .standard(proto: "absolute_altitude_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitudeDeg) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitudeDeg) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.absoluteAltitudeM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.latitudeDeg, fieldNumber: 1)
    }
    if self.longitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.longitudeDeg, fieldNumber: 2)
    }
    if self.absoluteAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.absoluteAltitudeM, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_GroundTruth, rhs: Mavsdk_Rpc_Telemetry_GroundTruth) -> Bool {
    if lhs.latitudeDeg != rhs.latitudeDeg {return false}
    if lhs.longitudeDeg != rhs.longitudeDeg {return false}
    if lhs.absoluteAltitudeM != rhs.absoluteAltitudeM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_FixedwingMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FixedwingMetrics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "airspeed_m_s"),
    2: .standard(proto: "throttle_percentage"),
    3: .standard(proto: "climb_rate_m_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.airspeedMS) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.throttlePercentage) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.climbRateMS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.airspeedMS != 0 {
      try visitor.visitSingularFloatField(value: self.airspeedMS, fieldNumber: 1)
    }
    if self.throttlePercentage != 0 {
      try visitor.visitSingularFloatField(value: self.throttlePercentage, fieldNumber: 2)
    }
    if self.climbRateMS != 0 {
      try visitor.visitSingularFloatField(value: self.climbRateMS, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_FixedwingMetrics, rhs: Mavsdk_Rpc_Telemetry_FixedwingMetrics) -> Bool {
    if lhs.airspeedMS != rhs.airspeedMS {return false}
    if lhs.throttlePercentage != rhs.throttlePercentage {return false}
    if lhs.climbRateMS != rhs.climbRateMS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_AccelerationFrd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccelerationFrd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "forward_m_s2"),
    2: .standard(proto: "right_m_s2"),
    3: .standard(proto: "down_m_s2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.forwardMS2) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.rightMS2) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downMS2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.forwardMS2 != 0 {
      try visitor.visitSingularFloatField(value: self.forwardMS2, fieldNumber: 1)
    }
    if self.rightMS2 != 0 {
      try visitor.visitSingularFloatField(value: self.rightMS2, fieldNumber: 2)
    }
    if self.downMS2 != 0 {
      try visitor.visitSingularFloatField(value: self.downMS2, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_AccelerationFrd, rhs: Mavsdk_Rpc_Telemetry_AccelerationFrd) -> Bool {
    if lhs.forwardMS2 != rhs.forwardMS2 {return false}
    if lhs.rightMS2 != rhs.rightMS2 {return false}
    if lhs.downMS2 != rhs.downMS2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_AngularVelocityFrd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AngularVelocityFrd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "forward_rad_s"),
    2: .standard(proto: "right_rad_s"),
    3: .standard(proto: "down_rad_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.forwardRadS) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.rightRadS) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downRadS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.forwardRadS != 0 {
      try visitor.visitSingularFloatField(value: self.forwardRadS, fieldNumber: 1)
    }
    if self.rightRadS != 0 {
      try visitor.visitSingularFloatField(value: self.rightRadS, fieldNumber: 2)
    }
    if self.downRadS != 0 {
      try visitor.visitSingularFloatField(value: self.downRadS, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_AngularVelocityFrd, rhs: Mavsdk_Rpc_Telemetry_AngularVelocityFrd) -> Bool {
    if lhs.forwardRadS != rhs.forwardRadS {return false}
    if lhs.rightRadS != rhs.rightRadS {return false}
    if lhs.downRadS != rhs.downRadS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_MagneticFieldFrd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MagneticFieldFrd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "forward_gauss"),
    2: .standard(proto: "right_gauss"),
    3: .standard(proto: "down_gauss"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.forwardGauss) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.rightGauss) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downGauss) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.forwardGauss != 0 {
      try visitor.visitSingularFloatField(value: self.forwardGauss, fieldNumber: 1)
    }
    if self.rightGauss != 0 {
      try visitor.visitSingularFloatField(value: self.rightGauss, fieldNumber: 2)
    }
    if self.downGauss != 0 {
      try visitor.visitSingularFloatField(value: self.downGauss, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_MagneticFieldFrd, rhs: Mavsdk_Rpc_Telemetry_MagneticFieldFrd) -> Bool {
    if lhs.forwardGauss != rhs.forwardGauss {return false}
    if lhs.rightGauss != rhs.rightGauss {return false}
    if lhs.downGauss != rhs.downGauss {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_Imu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Imu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "acceleration_frd"),
    2: .standard(proto: "angular_velocity_frd"),
    3: .standard(proto: "magnetic_field_frd"),
    4: .standard(proto: "temperature_degc"),
    5: .standard(proto: "timestamp_us"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accelerationFrd) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._angularVelocityFrd) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._magneticFieldFrd) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.temperatureDegc) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.timestampUs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accelerationFrd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._angularVelocityFrd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._magneticFieldFrd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.temperatureDegc != 0 {
      try visitor.visitSingularFloatField(value: self.temperatureDegc, fieldNumber: 4)
    }
    if self.timestampUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampUs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_Imu, rhs: Mavsdk_Rpc_Telemetry_Imu) -> Bool {
    if lhs._accelerationFrd != rhs._accelerationFrd {return false}
    if lhs._angularVelocityFrd != rhs._angularVelocityFrd {return false}
    if lhs._magneticFieldFrd != rhs._magneticFieldFrd {return false}
    if lhs.temperatureDegc != rhs.temperatureDegc {return false}
    if lhs.timestampUs != rhs.timestampUs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_GpsGlobalOrigin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GpsGlobalOrigin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latitude_deg"),
    2: .standard(proto: "longitude_deg"),
    3: .standard(proto: "altitude_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitudeDeg) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitudeDeg) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.altitudeM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.latitudeDeg, fieldNumber: 1)
    }
    if self.longitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.longitudeDeg, fieldNumber: 2)
    }
    if self.altitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.altitudeM, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_GpsGlobalOrigin, rhs: Mavsdk_Rpc_Telemetry_GpsGlobalOrigin) -> Bool {
    if lhs.latitudeDeg != rhs.latitudeDeg {return false}
    if lhs.longitudeDeg != rhs.longitudeDeg {return false}
    if lhs.altitudeM != rhs.altitudeM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_TelemetryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TelemetryResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_str"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resultStr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.resultStr.isEmpty {
      try visitor.visitSingularStringField(value: self.resultStr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Telemetry_TelemetryResult, rhs: Mavsdk_Rpc_Telemetry_TelemetryResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.resultStr != rhs.resultStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Telemetry_TelemetryResult.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNKNOWN"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_NO_SYSTEM"),
    3: .same(proto: "RESULT_CONNECTION_ERROR"),
    4: .same(proto: "RESULT_BUSY"),
    5: .same(proto: "RESULT_COMMAND_DENIED"),
    6: .same(proto: "RESULT_TIMEOUT"),
    7: .same(proto: "RESULT_UNSUPPORTED"),
  ]
}
