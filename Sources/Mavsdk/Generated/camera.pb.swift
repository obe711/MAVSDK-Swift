// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: camera.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Camera mode type.
enum Mavsdk_Rpc_Camera_Mode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Unknown
  case unknown // = 0

  /// Photo mode
  case photo // = 1

  /// Video mode
  case video // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .photo
    case 2: self = .video
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .photo: return 1
    case .video: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Camera_Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Camera_Mode] = [
    .unknown,
    .photo,
    .video,
  ]
}

#endif  // swift(>=4.2)

/// Photos range type.
enum Mavsdk_Rpc_Camera_PhotosRange: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// All the photos present on the camera
  case all // = 0

  /// Photos taken since MAVSDK got connected
  case sinceConnection // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .all
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .all
    case 1: self = .sinceConnection
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .all: return 0
    case .sinceConnection: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Camera_PhotosRange: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Camera_PhotosRange] = [
    .all,
    .sinceConnection,
  ]
}

#endif  // swift(>=4.2)

struct Mavsdk_Rpc_Camera_PrepareRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_PrepareResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_TakePhotoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_TakePhotoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_StartPhotoIntervalRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interval between photos (in seconds)
  var intervalS: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_StartPhotoIntervalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_StopPhotoIntervalRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_StopPhotoIntervalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_StartVideoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_StartVideoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_StopVideoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_StopVideoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_StartVideoStreamingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_StartVideoStreamingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_StopVideoStreamingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_StopVideoStreamingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_SetModeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Camera mode to set
  var mode: Mavsdk_Rpc_Camera_Mode = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_SetModeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_ListPhotosRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which photos should be listed (all or since connection)
  var photosRange: Mavsdk_Rpc_Camera_PhotosRange = .all

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_ListPhotosResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  /// List of capture infos (representing the photos)
  var captureInfos: [Mavsdk_Rpc_Camera_CaptureInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_SubscribeInformationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_InformationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Camera information
  var information: Mavsdk_Rpc_Camera_Information {
    get {return _information ?? Mavsdk_Rpc_Camera_Information()}
    set {_information = newValue}
  }
  /// Returns true if `information` has been explicitly set.
  var hasInformation: Bool {return self._information != nil}
  /// Clears the value of `information`. Subsequent reads from it will return its default value.
  mutating func clearInformation() {self._information = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _information: Mavsdk_Rpc_Camera_Information? = nil
}

struct Mavsdk_Rpc_Camera_SubscribeModeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_ModeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Camera mode
  var mode: Mavsdk_Rpc_Camera_Mode = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_SubscribeVideoStreamInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_VideoStreamInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Video stream info
  var videoStreamInfo: Mavsdk_Rpc_Camera_VideoStreamInfo {
    get {return _videoStreamInfo ?? Mavsdk_Rpc_Camera_VideoStreamInfo()}
    set {_videoStreamInfo = newValue}
  }
  /// Returns true if `videoStreamInfo` has been explicitly set.
  var hasVideoStreamInfo: Bool {return self._videoStreamInfo != nil}
  /// Clears the value of `videoStreamInfo`. Subsequent reads from it will return its default value.
  mutating func clearVideoStreamInfo() {self._videoStreamInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _videoStreamInfo: Mavsdk_Rpc_Camera_VideoStreamInfo? = nil
}

struct Mavsdk_Rpc_Camera_SubscribeCaptureInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_CaptureInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Capture info
  var captureInfo: Mavsdk_Rpc_Camera_CaptureInfo {
    get {return _captureInfo ?? Mavsdk_Rpc_Camera_CaptureInfo()}
    set {_captureInfo = newValue}
  }
  /// Returns true if `captureInfo` has been explicitly set.
  var hasCaptureInfo: Bool {return self._captureInfo != nil}
  /// Clears the value of `captureInfo`. Subsequent reads from it will return its default value.
  mutating func clearCaptureInfo() {self._captureInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _captureInfo: Mavsdk_Rpc_Camera_CaptureInfo? = nil
}

struct Mavsdk_Rpc_Camera_SubscribeStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Camera status
  var cameraStatus: Mavsdk_Rpc_Camera_Status {
    get {return _cameraStatus ?? Mavsdk_Rpc_Camera_Status()}
    set {_cameraStatus = newValue}
  }
  /// Returns true if `cameraStatus` has been explicitly set.
  var hasCameraStatus: Bool {return self._cameraStatus != nil}
  /// Clears the value of `cameraStatus`. Subsequent reads from it will return its default value.
  mutating func clearCameraStatus() {self._cameraStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraStatus: Mavsdk_Rpc_Camera_Status? = nil
}

struct Mavsdk_Rpc_Camera_SubscribeCurrentSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_CurrentSettingsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of current settings
  var currentSettings: [Mavsdk_Rpc_Camera_Setting] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_SubscribePossibleSettingOptionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_PossibleSettingOptionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of settings that can be changed
  var settingOptions: [Mavsdk_Rpc_Camera_SettingOptions] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_SetSettingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desired setting
  var setting: Mavsdk_Rpc_Camera_Setting {
    get {return _setting ?? Mavsdk_Rpc_Camera_Setting()}
    set {_setting = newValue}
  }
  /// Returns true if `setting` has been explicitly set.
  var hasSetting: Bool {return self._setting != nil}
  /// Clears the value of `setting`. Subsequent reads from it will return its default value.
  mutating func clearSetting() {self._setting = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _setting: Mavsdk_Rpc_Camera_Setting? = nil
}

struct Mavsdk_Rpc_Camera_SetSettingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

struct Mavsdk_Rpc_Camera_GetSettingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Requested setting
  var setting: Mavsdk_Rpc_Camera_Setting {
    get {return _setting ?? Mavsdk_Rpc_Camera_Setting()}
    set {_setting = newValue}
  }
  /// Returns true if `setting` has been explicitly set.
  var hasSetting: Bool {return self._setting != nil}
  /// Clears the value of `setting`. Subsequent reads from it will return its default value.
  mutating func clearSetting() {self._setting = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _setting: Mavsdk_Rpc_Camera_Setting? = nil
}

struct Mavsdk_Rpc_Camera_GetSettingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  /// Setting
  var setting: Mavsdk_Rpc_Camera_Setting {
    get {return _setting ?? Mavsdk_Rpc_Camera_Setting()}
    set {_setting = newValue}
  }
  /// Returns true if `setting` has been explicitly set.
  var hasSetting: Bool {return self._setting != nil}
  /// Clears the value of `setting`. Subsequent reads from it will return its default value.
  mutating func clearSetting() {self._setting = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
  fileprivate var _setting: Mavsdk_Rpc_Camera_Setting? = nil
}

struct Mavsdk_Rpc_Camera_FormatStorageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Camera_FormatStorageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraResult: Mavsdk_Rpc_Camera_CameraResult {
    get {return _cameraResult ?? Mavsdk_Rpc_Camera_CameraResult()}
    set {_cameraResult = newValue}
  }
  /// Returns true if `cameraResult` has been explicitly set.
  var hasCameraResult: Bool {return self._cameraResult != nil}
  /// Clears the value of `cameraResult`. Subsequent reads from it will return its default value.
  mutating func clearCameraResult() {self._cameraResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cameraResult: Mavsdk_Rpc_Camera_CameraResult? = nil
}

/// Result type.
struct Mavsdk_Rpc_Camera_CameraResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result enum value
  var result: Mavsdk_Rpc_Camera_CameraResult.Result = .unknown

  /// Human-readable English string describing the result
  var resultStr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible results returned for camera commands
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result
    case unknown // = 0

    /// Command executed successfully
    case success // = 1

    /// Command in progress
    case inProgress // = 2

    /// Camera is busy and rejected command
    case busy // = 3

    /// Camera denied the command
    case denied // = 4

    /// An error has occurred while executing the command
    case error // = 5

    /// Command timed out
    case timeout // = 6

    /// Command has wrong argument(s)
    case wrongArgument // = 7

    /// No system connected
    case noSystem // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .inProgress
      case 3: self = .busy
      case 4: self = .denied
      case 5: self = .error
      case 6: self = .timeout
      case 7: self = .wrongArgument
      case 8: self = .noSystem
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .inProgress: return 2
      case .busy: return 3
      case .denied: return 4
      case .error: return 5
      case .timeout: return 6
      case .wrongArgument: return 7
      case .noSystem: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mavsdk_Rpc_Camera_CameraResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Camera_CameraResult.Result] = [
    .unknown,
    .success,
    .inProgress,
    .busy,
    .denied,
    .error,
    .timeout,
    .wrongArgument,
    .noSystem,
  ]
}

#endif  // swift(>=4.2)

/// Position type in global coordinates.
struct Mavsdk_Rpc_Camera_Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Latitude in degrees (range: -90 to +90)
  var latitudeDeg: Double = 0

  /// Longitude in degrees (range: -180 to +180)
  var longitudeDeg: Double = 0

  /// Altitude AMSL (above mean sea level) in metres
  var absoluteAltitudeM: Float = 0

  /// Altitude relative to takeoff altitude in metres
  var relativeAltitudeM: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Quaternion type.
///
/// All rotations and axis systems follow the right-hand rule.
/// The Hamilton quaternion product definition is used.
/// A zero-rotation quaternion is represented by (1,0,0,0).
/// The quaternion could also be written as w + xi + yj + zk.
///
/// For more info see: https://en.wikipedia.org/wiki/Quaternion
struct Mavsdk_Rpc_Camera_Quaternion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Quaternion entry 0, also denoted as a
  var w: Float = 0

  /// Quaternion entry 1, also denoted as b
  var x: Float = 0

  /// Quaternion entry 2, also denoted as c
  var y: Float = 0

  /// Quaternion entry 3, also denoted as d
  var z: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Euler angle type.
///
/// All rotations and axis systems follow the right-hand rule.
/// The Euler angles follow the convention of a 3-2-1 intrinsic Tait-Bryan rotation sequence.
///
/// For more info see https://en.wikipedia.org/wiki/Euler_angles
struct Mavsdk_Rpc_Camera_EulerAngle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roll angle in degrees, positive is banking to the right
  var rollDeg: Float = 0

  /// Pitch angle in degrees, positive is pitching nose up
  var pitchDeg: Float = 0

  /// Yaw angle in degrees, positive is clock-wise seen from above
  var yawDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information about a picture just captured.
struct Mavsdk_Rpc_Camera_CaptureInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location where the picture was taken
  var position: Mavsdk_Rpc_Camera_Position {
    get {return _position ?? Mavsdk_Rpc_Camera_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  /// Attitude of the camera when the picture was taken (quaternion)
  var attitudeQuaternion: Mavsdk_Rpc_Camera_Quaternion {
    get {return _attitudeQuaternion ?? Mavsdk_Rpc_Camera_Quaternion()}
    set {_attitudeQuaternion = newValue}
  }
  /// Returns true if `attitudeQuaternion` has been explicitly set.
  var hasAttitudeQuaternion: Bool {return self._attitudeQuaternion != nil}
  /// Clears the value of `attitudeQuaternion`. Subsequent reads from it will return its default value.
  mutating func clearAttitudeQuaternion() {self._attitudeQuaternion = nil}

  /// Attitude of the camera when the picture was taken (euler angle)
  var attitudeEulerAngle: Mavsdk_Rpc_Camera_EulerAngle {
    get {return _attitudeEulerAngle ?? Mavsdk_Rpc_Camera_EulerAngle()}
    set {_attitudeEulerAngle = newValue}
  }
  /// Returns true if `attitudeEulerAngle` has been explicitly set.
  var hasAttitudeEulerAngle: Bool {return self._attitudeEulerAngle != nil}
  /// Clears the value of `attitudeEulerAngle`. Subsequent reads from it will return its default value.
  mutating func clearAttitudeEulerAngle() {self._attitudeEulerAngle = nil}

  /// Timestamp in UTC (since UNIX epoch) in microseconds
  var timeUtcUs: UInt64 = 0

  /// True if the capture was successful
  var isSuccess: Bool = false

  /// Zero-based index of this image since vehicle was armed
  var index: Int32 = 0

  /// Download URL of this image
  var fileURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Mavsdk_Rpc_Camera_Position? = nil
  fileprivate var _attitudeQuaternion: Mavsdk_Rpc_Camera_Quaternion? = nil
  fileprivate var _attitudeEulerAngle: Mavsdk_Rpc_Camera_EulerAngle? = nil
}

/// Type for video stream settings.
struct Mavsdk_Rpc_Camera_VideoStreamSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Frames per second
  var frameRateHz: Float = 0

  /// Horizontal resolution (in pixels)
  var horizontalResolutionPix: UInt32 = 0

  /// Vertical resolution (in pixels)
  var verticalResolutionPix: UInt32 = 0

  /// Bit rate (in bits per second)
  var bitRateBS: UInt32 = 0

  /// Video image rotation (clockwise, 0-359 degrees)
  var rotationDeg: UInt32 = 0

  /// Video stream URI
  var uri: String = String()

  /// Horizontal fov in degrees
  var horizontalFovDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information about the video stream.
struct Mavsdk_Rpc_Camera_VideoStreamInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Video stream settings
  var settings: Mavsdk_Rpc_Camera_VideoStreamSettings {
    get {return _settings ?? Mavsdk_Rpc_Camera_VideoStreamSettings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {self._settings = nil}

  /// Current status of video streaming
  var status: Mavsdk_Rpc_Camera_VideoStreamInfo.VideoStreamStatus = .notRunning

  /// Light-spectrum of the video stream
  var spectrum: Mavsdk_Rpc_Camera_VideoStreamInfo.VideoStreamSpectrum = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Video stream status type.
  enum VideoStreamStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Video stream is not running
    case notRunning // = 0

    /// Video stream is running
    case inProgress // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .notRunning
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notRunning
      case 1: self = .inProgress
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notRunning: return 0
      case .inProgress: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Video stream light spectrum type
  enum VideoStreamSpectrum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown
    case unknown // = 0

    /// Visible light
    case visibleLight // = 1

    /// Infrared
    case infrared // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .visibleLight
      case 2: self = .infrared
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .visibleLight: return 1
      case .infrared: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _settings: Mavsdk_Rpc_Camera_VideoStreamSettings? = nil
}

#if swift(>=4.2)

extension Mavsdk_Rpc_Camera_VideoStreamInfo.VideoStreamStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Camera_VideoStreamInfo.VideoStreamStatus] = [
    .notRunning,
    .inProgress,
  ]
}

extension Mavsdk_Rpc_Camera_VideoStreamInfo.VideoStreamSpectrum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Camera_VideoStreamInfo.VideoStreamSpectrum] = [
    .unknown,
    .visibleLight,
    .infrared,
  ]
}

#endif  // swift(>=4.2)

/// Information about the camera status.
struct Mavsdk_Rpc_Camera_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether video recording is currently in process
  var videoOn: Bool = false

  /// Whether a photo interval is currently in process
  var photoIntervalOn: Bool = false

  /// Used storage (in MiB)
  var usedStorageMib: Float = 0

  /// Available storage (in MiB)
  var availableStorageMib: Float = 0

  /// Total storage (in MiB)
  var totalStorageMib: Float = 0

  /// Elapsed time since starting the video recording (in seconds)
  var recordingTimeS: Float = 0

  /// Current folder name where media are saved
  var mediaFolderName: String = String()

  /// Storage status
  var storageStatus: Mavsdk_Rpc_Camera_Status.StorageStatus = .notAvailable

  /// Storage ID starting at 1
  var storageID: UInt32 = 0

  /// Storage type
  var storageType: Mavsdk_Rpc_Camera_Status.StorageType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Storage status type.
  enum StorageStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Status not available
    case notAvailable // = 0

    /// Storage is not formatted (i.e. has no recognized file system)
    case unformatted // = 1

    /// Storage is formatted (i.e. has recognized a file system)
    case formatted // = 2

    /// Storage status is not supported
    case notSupported // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .notAvailable
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notAvailable
      case 1: self = .unformatted
      case 2: self = .formatted
      case 3: self = .notSupported
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notAvailable: return 0
      case .unformatted: return 1
      case .formatted: return 2
      case .notSupported: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Storage type.
  enum StorageType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Storage type unknown
    case unknown // = 0

    /// Storage type USB stick
    case usbStick // = 1

    /// Storage type SD card
    case sd // = 2

    /// Storage type MicroSD card
    case microsd // = 3

    /// Storage type HD mass storage
    case hd // = 7

    /// Storage type other, not listed
    case other // = 254
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .usbStick
      case 2: self = .sd
      case 3: self = .microsd
      case 7: self = .hd
      case 254: self = .other
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .usbStick: return 1
      case .sd: return 2
      case .microsd: return 3
      case .hd: return 7
      case .other: return 254
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mavsdk_Rpc_Camera_Status.StorageStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Camera_Status.StorageStatus] = [
    .notAvailable,
    .unformatted,
    .formatted,
    .notSupported,
  ]
}

extension Mavsdk_Rpc_Camera_Status.StorageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Camera_Status.StorageType] = [
    .unknown,
    .usbStick,
    .sd,
    .microsd,
    .hd,
    .other,
  ]
}

#endif  // swift(>=4.2)

/// Type to represent a setting option.
struct Mavsdk_Rpc_Camera_Option {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the option (machine readable)
  var optionID: String = String()

  /// Description of the option (human readable)
  var optionDescription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type to represent a setting with a selected option.
struct Mavsdk_Rpc_Camera_Setting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of a setting (machine readable)
  var settingID: String = String()

  /// Description of the setting (human readable). This field is meant to be read from the drone, ignore it when setting.
  var settingDescription: String = String()

  /// Selected option
  var option: Mavsdk_Rpc_Camera_Option {
    get {return _option ?? Mavsdk_Rpc_Camera_Option()}
    set {_option = newValue}
  }
  /// Returns true if `option` has been explicitly set.
  var hasOption: Bool {return self._option != nil}
  /// Clears the value of `option`. Subsequent reads from it will return its default value.
  mutating func clearOption() {self._option = nil}

  /// If option is given as a range. This field is meant to be read from the drone, ignore it when setting.
  var isRange: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _option: Mavsdk_Rpc_Camera_Option? = nil
}

/// Type to represent a setting with a list of options to choose from.
struct Mavsdk_Rpc_Camera_SettingOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the setting (machine readable)
  var settingID: String = String()

  /// Description of the setting (human readable)
  var settingDescription: String = String()

  /// List of options or if range [min, max] or [min, max, interval]
  var options: [Mavsdk_Rpc_Camera_Option] = []

  /// If option is given as a range
  var isRange: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type to represent a camera information.
struct Mavsdk_Rpc_Camera_Information {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the camera vendor
  var vendorName: String = String()

  /// Name of the camera model
  var modelName: String = String()

  /// Focal length
  var focalLengthMm: Float = 0

  /// Horizontal sensor size
  var horizontalSensorSizeMm: Float = 0

  /// Vertical sensor size
  var verticalSensorSizeMm: Float = 0

  /// Horizontal image resolution in pixels
  var horizontalResolutionPx: UInt32 = 0

  /// Vertical image resolution in pixels
  var verticalResolutionPx: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mavsdk.rpc.camera"

extension Mavsdk_Rpc_Camera_Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_UNKNOWN"),
    1: .same(proto: "MODE_PHOTO"),
    2: .same(proto: "MODE_VIDEO"),
  ]
}

extension Mavsdk_Rpc_Camera_PhotosRange: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHOTOS_RANGE_ALL"),
    1: .same(proto: "PHOTOS_RANGE_SINCE_CONNECTION"),
  ]
}

extension Mavsdk_Rpc_Camera_PrepareRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrepareRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_PrepareRequest, rhs: Mavsdk_Rpc_Camera_PrepareRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_PrepareResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrepareResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_PrepareResponse, rhs: Mavsdk_Rpc_Camera_PrepareResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_TakePhotoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TakePhotoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_TakePhotoRequest, rhs: Mavsdk_Rpc_Camera_TakePhotoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_TakePhotoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TakePhotoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_TakePhotoResponse, rhs: Mavsdk_Rpc_Camera_TakePhotoResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StartPhotoIntervalRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartPhotoIntervalRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "interval_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.intervalS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.intervalS != 0 {
      try visitor.visitSingularFloatField(value: self.intervalS, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StartPhotoIntervalRequest, rhs: Mavsdk_Rpc_Camera_StartPhotoIntervalRequest) -> Bool {
    if lhs.intervalS != rhs.intervalS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StartPhotoIntervalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartPhotoIntervalResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StartPhotoIntervalResponse, rhs: Mavsdk_Rpc_Camera_StartPhotoIntervalResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StopPhotoIntervalRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopPhotoIntervalRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StopPhotoIntervalRequest, rhs: Mavsdk_Rpc_Camera_StopPhotoIntervalRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StopPhotoIntervalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopPhotoIntervalResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StopPhotoIntervalResponse, rhs: Mavsdk_Rpc_Camera_StopPhotoIntervalResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StartVideoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartVideoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StartVideoRequest, rhs: Mavsdk_Rpc_Camera_StartVideoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StartVideoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartVideoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StartVideoResponse, rhs: Mavsdk_Rpc_Camera_StartVideoResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StopVideoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopVideoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StopVideoRequest, rhs: Mavsdk_Rpc_Camera_StopVideoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StopVideoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopVideoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StopVideoResponse, rhs: Mavsdk_Rpc_Camera_StopVideoResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StartVideoStreamingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartVideoStreamingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StartVideoStreamingRequest, rhs: Mavsdk_Rpc_Camera_StartVideoStreamingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StartVideoStreamingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartVideoStreamingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StartVideoStreamingResponse, rhs: Mavsdk_Rpc_Camera_StartVideoStreamingResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StopVideoStreamingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopVideoStreamingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StopVideoStreamingRequest, rhs: Mavsdk_Rpc_Camera_StopVideoStreamingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StopVideoStreamingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopVideoStreamingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StopVideoStreamingResponse, rhs: Mavsdk_Rpc_Camera_StopVideoStreamingResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SetModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetModeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .unknown {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SetModeRequest, rhs: Mavsdk_Rpc_Camera_SetModeRequest) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SetModeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetModeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SetModeResponse, rhs: Mavsdk_Rpc_Camera_SetModeResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_ListPhotosRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPhotosRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photos_range"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.photosRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photosRange != .all {
      try visitor.visitSingularEnumField(value: self.photosRange, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_ListPhotosRequest, rhs: Mavsdk_Rpc_Camera_ListPhotosRequest) -> Bool {
    if lhs.photosRange != rhs.photosRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_ListPhotosResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPhotosResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
    2: .standard(proto: "capture_infos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.captureInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.captureInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.captureInfos, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_ListPhotosResponse, rhs: Mavsdk_Rpc_Camera_ListPhotosResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.captureInfos != rhs.captureInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SubscribeInformationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeInformationRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SubscribeInformationRequest, rhs: Mavsdk_Rpc_Camera_SubscribeInformationRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_InformationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InformationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "information"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._information) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._information {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_InformationResponse, rhs: Mavsdk_Rpc_Camera_InformationResponse) -> Bool {
    if lhs._information != rhs._information {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SubscribeModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeModeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SubscribeModeRequest, rhs: Mavsdk_Rpc_Camera_SubscribeModeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_ModeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .unknown {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_ModeResponse, rhs: Mavsdk_Rpc_Camera_ModeResponse) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SubscribeVideoStreamInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeVideoStreamInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SubscribeVideoStreamInfoRequest, rhs: Mavsdk_Rpc_Camera_SubscribeVideoStreamInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_VideoStreamInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoStreamInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_stream_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._videoStreamInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._videoStreamInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_VideoStreamInfoResponse, rhs: Mavsdk_Rpc_Camera_VideoStreamInfoResponse) -> Bool {
    if lhs._videoStreamInfo != rhs._videoStreamInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SubscribeCaptureInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeCaptureInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SubscribeCaptureInfoRequest, rhs: Mavsdk_Rpc_Camera_SubscribeCaptureInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_CaptureInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CaptureInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "capture_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._captureInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._captureInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_CaptureInfoResponse, rhs: Mavsdk_Rpc_Camera_CaptureInfoResponse) -> Bool {
    if lhs._captureInfo != rhs._captureInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SubscribeStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SubscribeStatusRequest, rhs: Mavsdk_Rpc_Camera_SubscribeStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_StatusResponse, rhs: Mavsdk_Rpc_Camera_StatusResponse) -> Bool {
    if lhs._cameraStatus != rhs._cameraStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SubscribeCurrentSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeCurrentSettingsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SubscribeCurrentSettingsRequest, rhs: Mavsdk_Rpc_Camera_SubscribeCurrentSettingsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_CurrentSettingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CurrentSettingsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.currentSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentSettings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.currentSettings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_CurrentSettingsResponse, rhs: Mavsdk_Rpc_Camera_CurrentSettingsResponse) -> Bool {
    if lhs.currentSettings != rhs.currentSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SubscribePossibleSettingOptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribePossibleSettingOptionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SubscribePossibleSettingOptionsRequest, rhs: Mavsdk_Rpc_Camera_SubscribePossibleSettingOptionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_PossibleSettingOptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PossibleSettingOptionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "setting_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.settingOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.settingOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.settingOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_PossibleSettingOptionsResponse, rhs: Mavsdk_Rpc_Camera_PossibleSettingOptionsResponse) -> Bool {
    if lhs.settingOptions != rhs.settingOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SetSettingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetSettingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "setting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._setting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._setting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SetSettingRequest, rhs: Mavsdk_Rpc_Camera_SetSettingRequest) -> Bool {
    if lhs._setting != rhs._setting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SetSettingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetSettingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SetSettingResponse, rhs: Mavsdk_Rpc_Camera_SetSettingResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_GetSettingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSettingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "setting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._setting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._setting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_GetSettingRequest, rhs: Mavsdk_Rpc_Camera_GetSettingRequest) -> Bool {
    if lhs._setting != rhs._setting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_GetSettingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSettingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
    2: .same(proto: "setting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._setting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._setting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_GetSettingResponse, rhs: Mavsdk_Rpc_Camera_GetSettingResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs._setting != rhs._setting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_FormatStorageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormatStorageRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_FormatStorageRequest, rhs: Mavsdk_Rpc_Camera_FormatStorageRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_FormatStorageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormatStorageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cameraResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cameraResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_FormatStorageResponse, rhs: Mavsdk_Rpc_Camera_FormatStorageResponse) -> Bool {
    if lhs._cameraResult != rhs._cameraResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_CameraResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CameraResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_str"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resultStr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.resultStr.isEmpty {
      try visitor.visitSingularStringField(value: self.resultStr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_CameraResult, rhs: Mavsdk_Rpc_Camera_CameraResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.resultStr != rhs.resultStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_CameraResult.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNKNOWN"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_IN_PROGRESS"),
    3: .same(proto: "RESULT_BUSY"),
    4: .same(proto: "RESULT_DENIED"),
    5: .same(proto: "RESULT_ERROR"),
    6: .same(proto: "RESULT_TIMEOUT"),
    7: .same(proto: "RESULT_WRONG_ARGUMENT"),
    8: .same(proto: "RESULT_NO_SYSTEM"),
  ]
}

extension Mavsdk_Rpc_Camera_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latitude_deg"),
    2: .standard(proto: "longitude_deg"),
    3: .standard(proto: "absolute_altitude_m"),
    4: .standard(proto: "relative_altitude_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitudeDeg) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitudeDeg) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.absoluteAltitudeM) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.relativeAltitudeM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.latitudeDeg, fieldNumber: 1)
    }
    if self.longitudeDeg != 0 {
      try visitor.visitSingularDoubleField(value: self.longitudeDeg, fieldNumber: 2)
    }
    if self.absoluteAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.absoluteAltitudeM, fieldNumber: 3)
    }
    if self.relativeAltitudeM != 0 {
      try visitor.visitSingularFloatField(value: self.relativeAltitudeM, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_Position, rhs: Mavsdk_Rpc_Camera_Position) -> Bool {
    if lhs.latitudeDeg != rhs.latitudeDeg {return false}
    if lhs.longitudeDeg != rhs.longitudeDeg {return false}
    if lhs.absoluteAltitudeM != rhs.absoluteAltitudeM {return false}
    if lhs.relativeAltitudeM != rhs.relativeAltitudeM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_Quaternion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Quaternion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "w"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.w) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.w != 0 {
      try visitor.visitSingularFloatField(value: self.w, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 3)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_Quaternion, rhs: Mavsdk_Rpc_Camera_Quaternion) -> Bool {
    if lhs.w != rhs.w {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_EulerAngle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EulerAngle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "roll_deg"),
    2: .standard(proto: "pitch_deg"),
    3: .standard(proto: "yaw_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.rollDeg) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.pitchDeg) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.yawDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rollDeg != 0 {
      try visitor.visitSingularFloatField(value: self.rollDeg, fieldNumber: 1)
    }
    if self.pitchDeg != 0 {
      try visitor.visitSingularFloatField(value: self.pitchDeg, fieldNumber: 2)
    }
    if self.yawDeg != 0 {
      try visitor.visitSingularFloatField(value: self.yawDeg, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_EulerAngle, rhs: Mavsdk_Rpc_Camera_EulerAngle) -> Bool {
    if lhs.rollDeg != rhs.rollDeg {return false}
    if lhs.pitchDeg != rhs.pitchDeg {return false}
    if lhs.yawDeg != rhs.yawDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_CaptureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CaptureInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "attitude_quaternion"),
    3: .standard(proto: "attitude_euler_angle"),
    4: .standard(proto: "time_utc_us"),
    5: .standard(proto: "is_success"),
    6: .same(proto: "index"),
    7: .standard(proto: "file_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._attitudeQuaternion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._attitudeEulerAngle) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timeUtcUs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isSuccess) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.fileURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._attitudeQuaternion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._attitudeEulerAngle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.timeUtcUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeUtcUs, fieldNumber: 4)
    }
    if self.isSuccess != false {
      try visitor.visitSingularBoolField(value: self.isSuccess, fieldNumber: 5)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 6)
    }
    if !self.fileURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fileURL, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_CaptureInfo, rhs: Mavsdk_Rpc_Camera_CaptureInfo) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._attitudeQuaternion != rhs._attitudeQuaternion {return false}
    if lhs._attitudeEulerAngle != rhs._attitudeEulerAngle {return false}
    if lhs.timeUtcUs != rhs.timeUtcUs {return false}
    if lhs.isSuccess != rhs.isSuccess {return false}
    if lhs.index != rhs.index {return false}
    if lhs.fileURL != rhs.fileURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_VideoStreamSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoStreamSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_rate_hz"),
    2: .standard(proto: "horizontal_resolution_pix"),
    3: .standard(proto: "vertical_resolution_pix"),
    4: .standard(proto: "bit_rate_b_s"),
    5: .standard(proto: "rotation_deg"),
    6: .same(proto: "uri"),
    7: .standard(proto: "horizontal_fov_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.frameRateHz) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.horizontalResolutionPix) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.verticalResolutionPix) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.bitRateBS) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.rotationDeg) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.horizontalFovDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frameRateHz != 0 {
      try visitor.visitSingularFloatField(value: self.frameRateHz, fieldNumber: 1)
    }
    if self.horizontalResolutionPix != 0 {
      try visitor.visitSingularUInt32Field(value: self.horizontalResolutionPix, fieldNumber: 2)
    }
    if self.verticalResolutionPix != 0 {
      try visitor.visitSingularUInt32Field(value: self.verticalResolutionPix, fieldNumber: 3)
    }
    if self.bitRateBS != 0 {
      try visitor.visitSingularUInt32Field(value: self.bitRateBS, fieldNumber: 4)
    }
    if self.rotationDeg != 0 {
      try visitor.visitSingularUInt32Field(value: self.rotationDeg, fieldNumber: 5)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 6)
    }
    if self.horizontalFovDeg != 0 {
      try visitor.visitSingularFloatField(value: self.horizontalFovDeg, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_VideoStreamSettings, rhs: Mavsdk_Rpc_Camera_VideoStreamSettings) -> Bool {
    if lhs.frameRateHz != rhs.frameRateHz {return false}
    if lhs.horizontalResolutionPix != rhs.horizontalResolutionPix {return false}
    if lhs.verticalResolutionPix != rhs.verticalResolutionPix {return false}
    if lhs.bitRateBS != rhs.bitRateBS {return false}
    if lhs.rotationDeg != rhs.rotationDeg {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.horizontalFovDeg != rhs.horizontalFovDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_VideoStreamInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoStreamInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
    2: .same(proto: "status"),
    3: .same(proto: "spectrum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.spectrum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != .notRunning {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.spectrum != .unknown {
      try visitor.visitSingularEnumField(value: self.spectrum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_VideoStreamInfo, rhs: Mavsdk_Rpc_Camera_VideoStreamInfo) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs.status != rhs.status {return false}
    if lhs.spectrum != rhs.spectrum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_VideoStreamInfo.VideoStreamStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIDEO_STREAM_STATUS_NOT_RUNNING"),
    1: .same(proto: "VIDEO_STREAM_STATUS_IN_PROGRESS"),
  ]
}

extension Mavsdk_Rpc_Camera_VideoStreamInfo.VideoStreamSpectrum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIDEO_STREAM_SPECTRUM_UNKNOWN"),
    1: .same(proto: "VIDEO_STREAM_SPECTRUM_VISIBLE_LIGHT"),
    2: .same(proto: "VIDEO_STREAM_SPECTRUM_INFRARED"),
  ]
}

extension Mavsdk_Rpc_Camera_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_on"),
    2: .standard(proto: "photo_interval_on"),
    3: .standard(proto: "used_storage_mib"),
    4: .standard(proto: "available_storage_mib"),
    5: .standard(proto: "total_storage_mib"),
    6: .standard(proto: "recording_time_s"),
    7: .standard(proto: "media_folder_name"),
    8: .standard(proto: "storage_status"),
    9: .standard(proto: "storage_id"),
    10: .standard(proto: "storage_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.videoOn) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.photoIntervalOn) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.usedStorageMib) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.availableStorageMib) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.totalStorageMib) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.recordingTimeS) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.mediaFolderName) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.storageStatus) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.storageID) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.storageType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.videoOn != false {
      try visitor.visitSingularBoolField(value: self.videoOn, fieldNumber: 1)
    }
    if self.photoIntervalOn != false {
      try visitor.visitSingularBoolField(value: self.photoIntervalOn, fieldNumber: 2)
    }
    if self.usedStorageMib != 0 {
      try visitor.visitSingularFloatField(value: self.usedStorageMib, fieldNumber: 3)
    }
    if self.availableStorageMib != 0 {
      try visitor.visitSingularFloatField(value: self.availableStorageMib, fieldNumber: 4)
    }
    if self.totalStorageMib != 0 {
      try visitor.visitSingularFloatField(value: self.totalStorageMib, fieldNumber: 5)
    }
    if self.recordingTimeS != 0 {
      try visitor.visitSingularFloatField(value: self.recordingTimeS, fieldNumber: 6)
    }
    if !self.mediaFolderName.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaFolderName, fieldNumber: 7)
    }
    if self.storageStatus != .notAvailable {
      try visitor.visitSingularEnumField(value: self.storageStatus, fieldNumber: 8)
    }
    if self.storageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.storageID, fieldNumber: 9)
    }
    if self.storageType != .unknown {
      try visitor.visitSingularEnumField(value: self.storageType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_Status, rhs: Mavsdk_Rpc_Camera_Status) -> Bool {
    if lhs.videoOn != rhs.videoOn {return false}
    if lhs.photoIntervalOn != rhs.photoIntervalOn {return false}
    if lhs.usedStorageMib != rhs.usedStorageMib {return false}
    if lhs.availableStorageMib != rhs.availableStorageMib {return false}
    if lhs.totalStorageMib != rhs.totalStorageMib {return false}
    if lhs.recordingTimeS != rhs.recordingTimeS {return false}
    if lhs.mediaFolderName != rhs.mediaFolderName {return false}
    if lhs.storageStatus != rhs.storageStatus {return false}
    if lhs.storageID != rhs.storageID {return false}
    if lhs.storageType != rhs.storageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_Status.StorageStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORAGE_STATUS_NOT_AVAILABLE"),
    1: .same(proto: "STORAGE_STATUS_UNFORMATTED"),
    2: .same(proto: "STORAGE_STATUS_FORMATTED"),
    3: .same(proto: "STORAGE_STATUS_NOT_SUPPORTED"),
  ]
}

extension Mavsdk_Rpc_Camera_Status.StorageType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORAGE_TYPE_UNKNOWN"),
    1: .same(proto: "STORAGE_TYPE_USB_STICK"),
    2: .same(proto: "STORAGE_TYPE_SD"),
    3: .same(proto: "STORAGE_TYPE_MICROSD"),
    7: .same(proto: "STORAGE_TYPE_HD"),
    254: .same(proto: "STORAGE_TYPE_OTHER"),
  ]
}

extension Mavsdk_Rpc_Camera_Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Option"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "option_id"),
    2: .standard(proto: "option_description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.optionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.optionDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.optionID.isEmpty {
      try visitor.visitSingularStringField(value: self.optionID, fieldNumber: 1)
    }
    if !self.optionDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.optionDescription, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_Option, rhs: Mavsdk_Rpc_Camera_Option) -> Bool {
    if lhs.optionID != rhs.optionID {return false}
    if lhs.optionDescription != rhs.optionDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_Setting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Setting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "setting_id"),
    2: .standard(proto: "setting_description"),
    3: .same(proto: "option"),
    4: .standard(proto: "is_range"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.settingID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.settingDescription) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.settingID.isEmpty {
      try visitor.visitSingularStringField(value: self.settingID, fieldNumber: 1)
    }
    if !self.settingDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.settingDescription, fieldNumber: 2)
    }
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.isRange != false {
      try visitor.visitSingularBoolField(value: self.isRange, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_Setting, rhs: Mavsdk_Rpc_Camera_Setting) -> Bool {
    if lhs.settingID != rhs.settingID {return false}
    if lhs.settingDescription != rhs.settingDescription {return false}
    if lhs._option != rhs._option {return false}
    if lhs.isRange != rhs.isRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_SettingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SettingOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "setting_id"),
    2: .standard(proto: "setting_description"),
    3: .same(proto: "options"),
    4: .standard(proto: "is_range"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.settingID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.settingDescription) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.settingID.isEmpty {
      try visitor.visitSingularStringField(value: self.settingID, fieldNumber: 1)
    }
    if !self.settingDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.settingDescription, fieldNumber: 2)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 3)
    }
    if self.isRange != false {
      try visitor.visitSingularBoolField(value: self.isRange, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_SettingOptions, rhs: Mavsdk_Rpc_Camera_SettingOptions) -> Bool {
    if lhs.settingID != rhs.settingID {return false}
    if lhs.settingDescription != rhs.settingDescription {return false}
    if lhs.options != rhs.options {return false}
    if lhs.isRange != rhs.isRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Camera_Information: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Information"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vendor_name"),
    2: .standard(proto: "model_name"),
    3: .standard(proto: "focal_length_mm"),
    4: .standard(proto: "horizontal_sensor_size_mm"),
    5: .standard(proto: "vertical_sensor_size_mm"),
    6: .standard(proto: "horizontal_resolution_px"),
    7: .standard(proto: "vertical_resolution_px"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vendorName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelName) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.focalLengthMm) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.horizontalSensorSizeMm) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.verticalSensorSizeMm) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.horizontalResolutionPx) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.verticalResolutionPx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vendorName.isEmpty {
      try visitor.visitSingularStringField(value: self.vendorName, fieldNumber: 1)
    }
    if !self.modelName.isEmpty {
      try visitor.visitSingularStringField(value: self.modelName, fieldNumber: 2)
    }
    if self.focalLengthMm != 0 {
      try visitor.visitSingularFloatField(value: self.focalLengthMm, fieldNumber: 3)
    }
    if self.horizontalSensorSizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.horizontalSensorSizeMm, fieldNumber: 4)
    }
    if self.verticalSensorSizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.verticalSensorSizeMm, fieldNumber: 5)
    }
    if self.horizontalResolutionPx != 0 {
      try visitor.visitSingularUInt32Field(value: self.horizontalResolutionPx, fieldNumber: 6)
    }
    if self.verticalResolutionPx != 0 {
      try visitor.visitSingularUInt32Field(value: self.verticalResolutionPx, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Camera_Information, rhs: Mavsdk_Rpc_Camera_Information) -> Bool {
    if lhs.vendorName != rhs.vendorName {return false}
    if lhs.modelName != rhs.modelName {return false}
    if lhs.focalLengthMm != rhs.focalLengthMm {return false}
    if lhs.horizontalSensorSizeMm != rhs.horizontalSensorSizeMm {return false}
    if lhs.verticalSensorSizeMm != rhs.verticalSensorSizeMm {return false}
    if lhs.horizontalResolutionPx != rhs.horizontalResolutionPx {return false}
    if lhs.verticalResolutionPx != rhs.verticalResolutionPx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
