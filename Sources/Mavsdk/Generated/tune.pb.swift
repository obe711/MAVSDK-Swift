// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tune.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An element of the tune
enum Mavsdk_Rpc_Tune_SongElement: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// After this element, start playing legato
  case styleLegato // = 0

  /// After this element, start playing normal
  case styleNormal // = 1

  /// After this element, start playing staccato
  case styleStaccato // = 2

  /// After this element, set the note duration to 1
  case duration1 // = 3

  /// After this element, set the note duration to 2
  case duration2 // = 4

  /// After this element, set the note duration to 4
  case duration4 // = 5

  /// After this element, set the note duration to 8
  case duration8 // = 6

  /// After this element, set the note duration to 16
  case duration16 // = 7

  /// After this element, set the note duration to 32
  case duration32 // = 8

  /// Play note A
  case noteA // = 9

  /// Play note B
  case noteB // = 10

  /// Play note C
  case noteC // = 11

  /// Play note D
  case noteD // = 12

  /// Play note E
  case noteE // = 13

  /// Play note F
  case noteF // = 14

  /// Play note G
  case noteG // = 15

  /// Play a rest
  case notePause // = 16

  /// After this element, sharp the note (half a step up)
  case sharp // = 17

  /// After this element, flat the note (half a step down)
  case flat // = 18

  /// After this element, shift the note 1 octave up
  case octaveUp // = 19

  /// After this element, shift the note 1 octave down
  case octaveDown // = 20
  case UNRECOGNIZED(Int)

  init() {
    self = .styleLegato
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .styleLegato
    case 1: self = .styleNormal
    case 2: self = .styleStaccato
    case 3: self = .duration1
    case 4: self = .duration2
    case 5: self = .duration4
    case 6: self = .duration8
    case 7: self = .duration16
    case 8: self = .duration32
    case 9: self = .noteA
    case 10: self = .noteB
    case 11: self = .noteC
    case 12: self = .noteD
    case 13: self = .noteE
    case 14: self = .noteF
    case 15: self = .noteG
    case 16: self = .notePause
    case 17: self = .sharp
    case 18: self = .flat
    case 19: self = .octaveUp
    case 20: self = .octaveDown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .styleLegato: return 0
    case .styleNormal: return 1
    case .styleStaccato: return 2
    case .duration1: return 3
    case .duration2: return 4
    case .duration4: return 5
    case .duration8: return 6
    case .duration16: return 7
    case .duration32: return 8
    case .noteA: return 9
    case .noteB: return 10
    case .noteC: return 11
    case .noteD: return 12
    case .noteE: return 13
    case .noteF: return 14
    case .noteG: return 15
    case .notePause: return 16
    case .sharp: return 17
    case .flat: return 18
    case .octaveUp: return 19
    case .octaveDown: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Mavsdk_Rpc_Tune_SongElement: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Tune_SongElement] = [
    .styleLegato,
    .styleNormal,
    .styleStaccato,
    .duration1,
    .duration2,
    .duration4,
    .duration8,
    .duration16,
    .duration32,
    .noteA,
    .noteB,
    .noteC,
    .noteD,
    .noteE,
    .noteF,
    .noteG,
    .notePause,
    .sharp,
    .flat,
    .octaveUp,
    .octaveDown,
  ]
}

#endif  // swift(>=4.2)

struct Mavsdk_Rpc_Tune_PlayTuneRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The tune to be played
  var tuneDescription: Mavsdk_Rpc_Tune_TuneDescription {
    get {return _tuneDescription ?? Mavsdk_Rpc_Tune_TuneDescription()}
    set {_tuneDescription = newValue}
  }
  /// Returns true if `tuneDescription` has been explicitly set.
  var hasTuneDescription: Bool {return self._tuneDescription != nil}
  /// Clears the value of `tuneDescription`. Subsequent reads from it will return its default value.
  mutating func clearTuneDescription() {self._tuneDescription = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tuneDescription: Mavsdk_Rpc_Tune_TuneDescription? = nil
}

struct Mavsdk_Rpc_Tune_PlayTuneResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tuneResult: Mavsdk_Rpc_Tune_TuneResult {
    get {return _tuneResult ?? Mavsdk_Rpc_Tune_TuneResult()}
    set {_tuneResult = newValue}
  }
  /// Returns true if `tuneResult` has been explicitly set.
  var hasTuneResult: Bool {return self._tuneResult != nil}
  /// Clears the value of `tuneResult`. Subsequent reads from it will return its default value.
  mutating func clearTuneResult() {self._tuneResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tuneResult: Mavsdk_Rpc_Tune_TuneResult? = nil
}

/// Tune description, containing song elements and tempo.
struct Mavsdk_Rpc_Tune_TuneDescription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of song elements (notes, pauses, ...) to be played
  var songElements: [Mavsdk_Rpc_Tune_SongElement] = []

  /// The tempo of the song (range: 32 - 255)
  var tempo: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Tune_TuneResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result enum value
  var result: Mavsdk_Rpc_Tune_TuneResult.Result = .unknown

  /// Human-readable English string describing the result
  var resultStr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible results returned for tune requests.
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result
    case unknown // = 0

    /// Request succeeded
    case success // = 1

    /// Invalid tempo (range: 32 - 255)
    case invalidTempo // = 2

    /// Invalid tune: encoded string must be at most 247 chars
    case tuneTooLong // = 3

    /// Failed to send the request
    case error // = 4

    /// No system connected
    case noSystem // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .invalidTempo
      case 3: self = .tuneTooLong
      case 4: self = .error
      case 5: self = .noSystem
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .invalidTempo: return 2
      case .tuneTooLong: return 3
      case .error: return 4
      case .noSystem: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mavsdk_Rpc_Tune_TuneResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Tune_TuneResult.Result] = [
    .unknown,
    .success,
    .invalidTempo,
    .tuneTooLong,
    .error,
    .noSystem,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mavsdk.rpc.tune"

extension Mavsdk_Rpc_Tune_SongElement: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SONG_ELEMENT_STYLE_LEGATO"),
    1: .same(proto: "SONG_ELEMENT_STYLE_NORMAL"),
    2: .same(proto: "SONG_ELEMENT_STYLE_STACCATO"),
    3: .same(proto: "SONG_ELEMENT_DURATION_1"),
    4: .same(proto: "SONG_ELEMENT_DURATION_2"),
    5: .same(proto: "SONG_ELEMENT_DURATION_4"),
    6: .same(proto: "SONG_ELEMENT_DURATION_8"),
    7: .same(proto: "SONG_ELEMENT_DURATION_16"),
    8: .same(proto: "SONG_ELEMENT_DURATION_32"),
    9: .same(proto: "SONG_ELEMENT_NOTE_A"),
    10: .same(proto: "SONG_ELEMENT_NOTE_B"),
    11: .same(proto: "SONG_ELEMENT_NOTE_C"),
    12: .same(proto: "SONG_ELEMENT_NOTE_D"),
    13: .same(proto: "SONG_ELEMENT_NOTE_E"),
    14: .same(proto: "SONG_ELEMENT_NOTE_F"),
    15: .same(proto: "SONG_ELEMENT_NOTE_G"),
    16: .same(proto: "SONG_ELEMENT_NOTE_PAUSE"),
    17: .same(proto: "SONG_ELEMENT_SHARP"),
    18: .same(proto: "SONG_ELEMENT_FLAT"),
    19: .same(proto: "SONG_ELEMENT_OCTAVE_UP"),
    20: .same(proto: "SONG_ELEMENT_OCTAVE_DOWN"),
  ]
}

extension Mavsdk_Rpc_Tune_PlayTuneRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayTuneRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tune_description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tuneDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tuneDescription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Tune_PlayTuneRequest, rhs: Mavsdk_Rpc_Tune_PlayTuneRequest) -> Bool {
    if lhs._tuneDescription != rhs._tuneDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Tune_PlayTuneResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayTuneResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tune_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tuneResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tuneResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Tune_PlayTuneResponse, rhs: Mavsdk_Rpc_Tune_PlayTuneResponse) -> Bool {
    if lhs._tuneResult != rhs._tuneResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Tune_TuneDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TuneDescription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "song_elements"),
    2: .same(proto: "tempo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.songElements) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.tempo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.songElements.isEmpty {
      try visitor.visitPackedEnumField(value: self.songElements, fieldNumber: 1)
    }
    if self.tempo != 0 {
      try visitor.visitSingularInt32Field(value: self.tempo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Tune_TuneDescription, rhs: Mavsdk_Rpc_Tune_TuneDescription) -> Bool {
    if lhs.songElements != rhs.songElements {return false}
    if lhs.tempo != rhs.tempo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Tune_TuneResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TuneResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_str"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resultStr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.resultStr.isEmpty {
      try visitor.visitSingularStringField(value: self.resultStr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Tune_TuneResult, rhs: Mavsdk_Rpc_Tune_TuneResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.resultStr != rhs.resultStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Tune_TuneResult.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNKNOWN"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_INVALID_TEMPO"),
    3: .same(proto: "RESULT_TUNE_TOO_LONG"),
    4: .same(proto: "RESULT_ERROR"),
    5: .same(proto: "RESULT_NO_SYSTEM"),
  ]
}
